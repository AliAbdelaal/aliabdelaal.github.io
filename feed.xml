<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-03-28T00:45:07+00:00</updated><id>/feed.xml</id><title type="html">Ali’s Workspace</title><subtitle>A personal blog about python, machine learning and natural language processing.</subtitle><author><name>Ali Abdelaal</name></author><entry><title type="html">Introduction to NLP in Arabic - part 2</title><link href="/blog/intro-to-nlp-p2/" rel="alternate" type="text/html" title="Introduction to NLP in Arabic - part 2" /><published>2023-03-27T00:00:00+00:00</published><updated>2023-03-27T00:00:00+00:00</updated><id>/blog/intro-to-nlp-p2</id><content type="html" xml:base="/blog/intro-to-nlp-p2/"><![CDATA[<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>

<script>addBackToTop({
  diameter: 56,
  backgroundColor: 'rgb(128, 128, 128)',
  textColor: '#fff'
})</script>

<h2 class="text-right" id="مقدمة">مقدمة</h2>

<div dir="rtl">
هذا المقال تكملة للمقال السابق، يمكنك الاطلاع عليه من <a href="/blog/intro-to-nlp-p1/">هنا</a>
</div>

<div dir="rtl">
في المقال السابق تحدثنا عن نماذج مختلفة لمعالجة النصوص باستخدام خوارزميات تعلم الآلة، وتوقفنا عند بعض النقاط عند كل نموذج، دعنا نراجعها سريعا.
</div>

<div dir="rtl">
<ul>

<li><div dir="rtl">
ذكرنا في المرة السابقة استخدام Bag of words و وضحنا ان هذا النموذج لايأخذ في الحسبان ترتيب الكلمات وايضا لا يستطيع فهم معاني الكلمات فبالنسبة لهذا النموذج كل الكلمات سواء و الفارق هو عدد مرات تكرارهم.
</div></li>

<li><div dir="rtl">
ذكرنا ايضا كيف ان استخدام معدل تكرار الكلمة في النصوص (TFIDF) يمكن ان يساعد في تميز الكلمات المهمة عن باقي الكلمات ولكنه ايضا يعاني من نفس مشاكل الطريقة السابقة.
</div></li>

<li><div dir="rtl">
ثم ذكرنا نموذج متجهات الكلمات word2vec و ذكرنا كيف ان استخدام هذا النموذج يساعد في الحصول على متجه يعبر عن معنى الكلمات ولكن مازال لدينا بعض الملحوظات مثل ان الكلمة تحصل على نفس المتجه بغض النظر عن اختلاف السياق.
</div></li>

</ul>
</div>

<div dir="rtl">
في هذا المقال سنتعرف على كيفية التغلب على المشاكل السابقة باستخدام نماذج اكثر تطورا، سنتحدث عن الجمع بين نموذج word2vec و نموذج CNN لجمع اكتر من متجه و محاكاة طريقة ال N-Grams. أيضا سنتحدث عن محاكاة البيانات التسلسلية (sequential data) باستخدام نموذج RNN.</div>

<h2 class="text-right" id="كيف-يعمل-word2vec">كيف يعمل word2vec</h2>

<div dir="rtl">
فهم كيفية عمل هذا النموذج سوف تساعدنا على معرفة حدوده بشكل افضل و ربما كيفية التغلب عليها!
</div>

<div dir="rtl">
يوجد نوعان من نموذج word2vec هما CBOW (continous bag of word) و skip-gram، النوعان يختلفان في طريقة تدريبهما قليلا لكن الاستخدام لاحقا يكون في نفس السياق الا وهو توليد متجهات ذات معنى للكلمة.
</div>

<p><br /></p>

<p><img src="/assets/images/intro-to-nlp-p2/word2vec.png" alt="word2vec-arch" class="align-center" /></p>
<center><a href="https://arxiv.org/abs/1301.3781">المصدر</a></center>

<h3 class="text-right" id="cbow">CBOW</h3>

<div dir="rtl">
طريقة ال CBOW تعتمد على تعلم الكلمة الوسطى من الكلمات المحيطة، هذا عن طريق ادخال متجهات الكلمات المحيطة و محاولة تعلم الكلمة الوسطى
</div>

<div dir="rtl">
بالطبع في البداية لن يتوقع النموذج الكلمة الصحيحة ولكن مع التدريب و محاولة تقليص الخطأ باستخدام اسلوب <a href="/blog/gradient-descent-family/">النزول التدريجي في معدل الخطأ (gradient descent)</a> يتحسن اداء النموذج ليستطيع توقع الكلمة الصحيحة اذا ادخلنا الكلمات المحيطة، على سبيل المثال عندما ندخل للنموذج اريد ان ... كوب عصير، سيقوم النموذج بتوقع ان الكلمة الوسطى هنا هي "اشرب" لان هذا ما يدل عليه السياق.
</div>

<div dir="rtl" class="notice--info">
نماذج التعلم العميق (deep learning) تعتبر بالاساس معادلات معقدة تحاول تخمين ما هي القيم التقريبية للمتغيرات التي تكون هذه المعادلات في البداية يتم تخمين قيم عشوائية لهذه المتغيرات و يتم احتساب قيم التوقعات و مقارنتها بالقيم الحقيقية و احتساب معدل الخطأ بينهما، و باستخدام خصائص التفاضل يمكننا معرفة التغييرات المطلوبة في كل متغير حتى نقوم بتقليل معدل الخطأ و يحدث هذا في عملية ال (gradient descent) يمكنك مراجعة تفاصيل اكثر في <a href="/blog/gradient-descent-family/">مقال سابق</a> حيث نتحدث عن تفاصيل هذه العملية بشكل اكبر.
</div>

<p><br /></p>

<p><img src="https://cdn-images-1.medium.com/max/800/1*d66FyqIMWtDCtOuJ_GcqAg.png" alt="word2vec-cbow" class="align-center" /></p>
<center><a href="https://www.kdnuggets.com/2018/04/implementing-deep-learning-methods-feature-engineering-text-data-cbow.html">المصدر</a></center>

<h3 class="text-right" id="skip-gram">Skip-gram</h3>

<div dir="rtl">
طريقة ال skip-gram تعتمد على تعلم السياق من الكلمة الوسطى (عكس الطريقة السابقة).
</div>

<div dir="rtl">
لتبسيط طريقة تعلم هذا النموذج نقوم بتحضير المدخلات لهذا النموذج على النحو التالي.
</div>

<table>
  <thead>
    <tr>
      <td align="center">السياق<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>    
        <span>&nbsp;&nbsp;</span>
      </td>
      <td align="center">الكلمة قبل<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>        
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;</span>
      </td>
      <td align="center">الكلمة بعد<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>    
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>     
        <span>&nbsp;&nbsp;</span>        
      </td>
      <td align="center">صحة السياق<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>    
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>     
        <span>&nbsp;&nbsp;</span>        
      </td>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td align="center">شرب<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>    
        <span>&nbsp;&nbsp;</span>
      </td>
      <td align="center">اريد<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>        
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;</span>
      </td>
      <td align="center">العصير<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>    
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>     
        <span>&nbsp;&nbsp;</span>        
      </td>
      <td align="center">1<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>    
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>     
        <span>&nbsp;&nbsp;</span>        
      </td>
    </tr>
    <tr>
      <td align="center">اكل<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>    
        <span>&nbsp;&nbsp;</span>
      </td>
      <td align="center">اريد<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>        
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;</span>
      </td>
      <td align="center">العصير<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>    
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>     
        <span>&nbsp;&nbsp;</span>        
      </td>
      <td align="center">0<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>    
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>     
        <span>&nbsp;&nbsp;</span>        
      </td>
    </tr>

  </tbody>
</table>

<div dir="rtl">
يمكنك ان ترى هنا اننا استخدمنا كلمة واحدة قبل و بعد كلمة السياق لكن يمكن ان يكون اكثر او اقل (اقل بان نستخدم كلمة واحدة قبل او بعد).
</div>

<div dir="rtl">
هنا يصبح هدف النموذج ان يتوقع إذا كانت الكلمات المعطاه تنتمي الي نفس السياق ام لا و ايضا في البداية لن يتوقع النموذج الاجابة الصحيحة ولكن بعد التدريب و التصحيح يمكنه ذلك.
</div>

<p><br />
<img src="https://cdn-images-1.medium.com/max/800/1*4Uil1zWWF5-jlt-FnRJgAQ.png" alt="word2vec-skip-gram" class="align-center" /></p>
<center><a href="https://www.kdnuggets.com/2018/04/implementing-deep-learning-methods-feature-engineering-text-data-skip-gram.html">المصدر</a></center>

<div dir="rtl" class="notice--info">
استخدام نماذج ايجابية و سلبية في التدريب يعد من اشهر الطرق في تدريب نماذج تعلم اللغة و تسمى هذه الطريقة بال (negative sampling) يمكنك الاطلاع على معلومات اكثر من خلال <a href="https://www.coursera.org/lecture/nlp-sequence-models/negative-sampling-Iwx0e">هذا الفيديو القصير</a>.
</div>

<h3 class="text-right" id="الاستخدام-بعد-التدريب">الاستخدام بعد التدريب</h3>

<div dir="rtl">
بعد انتهاء عملية التدريب نقوم باستخراج مرحلة تحويل النص الي متجه (embedding layer) بعد ان تعلمت كيف تصف الكلمة المعطاه بمتجه يمثل معناها، و في هذه المرحلة كل كلمة تم التدريب عليها لها متجه ثابت الان لا يمكن تغييره بناءا على السياق الخاص بالجملة و لكنه بالتأكيد افضل من استخدام الطرق السابقة مثل (bag of words) للتعبير عن النصوص.
</div>

<p><img src="https://www.tensorflow.org/text/guide/images/embedding2.png" alt="word-embeddings" class="align-center" /></p>
<div dir="rtl">
<center>مثال على استخدام ال embdding layer لمتجه حجمه 4 متغيرات. <a href="https://www.tensorflow.org/text/guide/word_embeddings">المصدر</a></center></div>

<h2 class="text-right" id="استخدام-ال-cnn-في-معالجة-اللغة">استخدام ال CNN في معالجة اللغة</h2>

<div dir="rtl">
تعد ال CNN (Convolutional Neural Network) الاكثر شهرة و استخداما في مجال معالجة الصور ولكن ايضا تستخدم في معالجة النصوص كما سنرى في الامثلة الاتية.
</div>

<h3 class="text-right" id="محاكاة-مجموعة-الكلمات-من-متجهات-الكلمات-n-gram-using-cnn">محاكاة مجموعة الكلمات من متجهات الكلمات (N-Gram using CNN)</h3>

<div dir="rtl">
تكلمنا في المقال السابق عن كيف ان استخدام اكثر من كلمة كوحدة للمعالجة (N-grams) يساعد على فهم معلومات اكثر في النص لان بعض المصطلحات يشمل اكثر من كلمة مثل مصطلح (حسبي الله  و نعم الوكيل) على سبيل المثال.
</div>

<div dir="rtl">
يمكننا استخدام ال CNN لتحصيل المعلومات التي تشتمل عليها مجموعة كلمات من متجهاتها، باستخدام طبيعة ال CNN الالتفافية يمكننا ان نمر على اكثر من كلمة باستخدام نافذة متحركة بحجم معين (مثلا 3 للتعبير عن 3-grams) كما هو موضح في المثال بالاسفل.
</div>

<p><img src="https://cezannec.github.io/assets/cnn_text/conv_maxpooling_steps.gif" alt="cnn-n-grams" class="align-center" /></p>
<div dir="rtl">
<center><a href="https://cezannec.github.io/CNN_Text_Classification/">المصدر</a></center></div>

<h3 class="text-right" id="تعلم-متجهات-الاحرف-char-embeddings">تعلم متجهات الاحرف (char embeddings)</h3>

<div dir="rtl">
يمكن ايضا استخدام ال CNN على مستوى الحروف لتعلم ما تعبر عنه الحروف و بالتالي ببناء اكثر من طبقة متتالية من نوعية CNN يمكن تكوين معرفة عن النص ككل، فكل طبقة/مرحلة سوف تتعلم مما تعلمته السابقة.
</div>

<div dir="rtl" class="notice--info">
استخدام الحروف بدلا للكلمات يساعد على تفادي عدم معرفة الكلمات الجديدة، ويساعد ايضا على الاستفادة من التكوين المشترك لبعض الكلمات و الاجزاء المشتركة على سبيل المثال يمكننا ان ندرك ان يحب و احب و يحبوا يشتركوا في حرفي الحاء و الباء و لذلك فان الكلمات المشتقة منها يمكن للنوذج معرفتها على عكس النماذج التي تعتمد على الكلمات كوحدة للمعالجة اذ ان الكلمة اذا كانت جديدة شكليا بزيادة حرف على سبيل المثال لن يعرفها النموذج، هذه الطريقة تم استخدامها في نموذج <a href="https://fasttext.cc/">fasttext</a>  الخاص بشركة facebook، حيث انه استخدم بالاساس مجموعة حروف بدل من كلمات محددة و قد اظهر تحسن ملحوظ عن استخدام الكلمات فقط في معمارية CBOW و skip-gram لاستخراج المتجهات.
</div>

<div dir="rtl">
</div>

<p><img src="https://www.researchgate.net/profile/Hoang-Pham-17/publication/316875275/figure/fig1/AS:493031154556929@1494559195862/The-CNN-for-extracting-character-level-features-of-word-Hoc-sinh-Student.png" alt="char-embeddings-cnn" class="align-center" /></p>
<div dir="rtl">
<center><a href="https://www.researchgate.net/figure/The-CNN-for-extracting-character-level-features-of-word-Hoc-sinh-Student_fig1_316875275">المصدر</a></center></div>

<h2 class="text-right" id="محاكاة-البيانات-التسلسلية-sequential-modeling">محاكاة البيانات التسلسلية (Sequential modeling)</h2>

<div dir="rtl">
تعد البيانات النصية بيانات تسلسلية، إذ ان ترتيب الكلمات قد يغير المعنى تماما و بالتالي لكي يستطيع نموذج تعلم ما يحتويه النص لابد ان يأخذ في الاعتبار التسلسل و ترتيب الكلمات، و هذا ما لم يفعله ايا من النماذج السابق ذكرها، كما ترى في المثال هنا ان استخدام الشبكة العصبية التقليدية (ANN) ليس لديه اي معلومة عن ترتيب النص لان تغير النص لن يغير في معادلته شئ.
</div>

<p><img src="/assets/images/intro-to-nlp-p2/ann.png" alt="ann-words" class="align-center" /></p>
<center>استخدام شبكة عصبية مع الكلمات بفرض استخدام الكلمات كوحدة معالجة</center>

\[h1('product','was','not','good')=\]

<p><br />
\(W_{1,1}*'product'+W_{1,2}*'was'+W_{1,3}*'not'+ W_{1,4}*'good'\)</p>

<div dir="rtl">
لاحظ هنا ان اختلاف الترتيب لن يغير في المعني شئ لانه لا توجد آلية لتعلم العلاقة التي تنشئ من ترتيب الكلمات بشكل معين.
</div>

<div dir="rtl">
يمكننا تعديل هذه المعمارية بإضافة آلية لتعلم العلاقة التي تنشأ من ترتيب النص كما يلي
</div>

<p><img src="/assets/images/intro-to-nlp-p2/rnn.png" alt="rnn-words" class="align-center" /></p>
<center>الشبكة العصبية التكرارية (Recurrent Neural Network)</center>

\[h1(x) = {\color{Red} h1('good', } {\color{Green} h1('not',} {\color{Blue} h1('was', } {\color{Yellow} h1('product', '&lt;sos&gt;')}{\color{Blue} )}{\color{Green} )}{\color{Red} )}\]

<div dir="rtl">
كما نرى هنا كل خطوة في هذه المعمارية تعتمد على الخطوة السابقة لها بالتالي يمكن للنموذج ان يتعلم ما يعنيه ترتيب الكلمات بشكل افضل.
</div>

<div dir="rtl" class="notice--info">
الشبكة التكرارية تعمل عن طريق معالجة النصوص بالتتالي، اي ان نفس وحدة المعالجة (الخلية/cell) تقوم بمعالجة الكلمة الاولى ثم الكلمة الثانية و هكذا و لاحظ هنا ان نفس الوحدة تعالج الكلمات بالتتالي و هذا يمنحها القدرة على تعلم العلاقة الموجودة بين الكلمات بناءا على ترتيبهم.
<br />

<center>
<img src="https://www.outsystems.com/blog/-/media/images/blog/posts/graph-neural-networks/nn-gif-2.gif?h=393&amp;w=750&amp;updated=20220111091724" /></center>
<center><a href="https://www.outsystems.com/blog/posts/graph-neural-networks/">المصدر</a></center>

</div>

<div dir="rtl">
تقوم هذه المعمارية ببناء فكرة عن النص في كل خطوة زمنية، و هنا الخطوة الزمنية تعني ترتيب الكلمات اي ان الخطوة الزمنية الاولى هي الكلمة الاولى و هكذا، ويمكننا القول ان عند اي نقطة زمنية تقوم الشبكة بتكوين معلومات عن النص حتى هذه النقطة في الزمن و بالتالي عند اخر كلمة ستكون الشبكة كونت فكرة عن النص ككل.
</div>

<p><br /></p>

<div dir="rtl">
يمكن استخدام هذه المعمارية في حل العديد من مسائل معالجة اللغة كما يلي.
</div>

<p><img src="https://camo.githubusercontent.com/dd88a4672c10fc5e3d6fcf33bcbc4f142f14bbdd3929aa7a336b8c50bc7033fb/687474703a2f2f6b617270617468792e6769746875622e696f2f6173736574732f726e6e2f64696167732e6a706567" alt="rnn-different-approaches" /></p>
<center><a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/">المصدر</a></center>

<div dir="rtl">
الشكل السابق يمثل 5 انواع من مسائل معالجة اللغة
<ul>
<li>الاول (one-to-one) يمثل الطريقة غير التسلسلية حيث حجم المدخلات و المخرجات ثابت.</li>
<li>الثاني (one-to-many) عندما نستخدم مدخل واحد مقابل اكثر من نتيجة مثل وصف الصور حيث يكون المدخل هو الصورة و النتيجة هي النص الذي يصف الكلمة و بالطبع يمكن ان يكون اكثر من كلمة.</li>
<li>الثالث (many-to-one) يعبر عن اكثر من مدخل (قطعة نصية على سبيل المثال) مقابل نتيجة واحدة (تصنيف النص اذا كان ايجابي او سلبي على سبيل المثال).</li>
<li>الرابع (many-to-many) هنا يتم استهلاك المدخلات كلها قبل ان يتم بناء النتيجة والامثلة على هذا النوع تشمل (الترجمة الآلية و تلخيص النصوص و غيرها).</li>
<li>الخامس (many-to-many) مثل السابق ولكن هنا يوجد نتيجة مباشرة لكل وحدة مدخلة (الوحدة قد تكون كلمة او حرف او مجموعة حروف (character n-grams) على حسب تعريف المدخلات) و احد الامثلة على هذا النوع هو التعرف على الاسماء المعرفة في النص (Named Entity Recognition).</li>
</ul>
</div>

<h3 class="text-right" id="كيفية-عمل-الشبكة-التكرارية-rnn">كيفية عمل الشبكة التكرارية (RNN)</h3>

<div dir="rtl">
تعمل الشبكة التكرارية على تعلم العلاقة التي تنشأ من ترتيب النصوص عن طريق تعلم مجموعة من المتغيرات التي تحدد ما الذي يجب تعلمه من النص الحالي و ما الذي يجب تعلمه من الخطوة السابقة (t-1)، كما نرى في الرسم الآتي:
<ol>
<li>ان الكلمة الحالية (Very) يتم معالجتها لتوليد متجه يعبر عنها (Very vector).</li>
<li>يتم معالجة هذا المتجه من خلال المصفوفة X(t) و هي المسئولة عن اضافة ما يجب اضافته و ازالة ما لا تحتاجه الشبكة لتعلم ما يعنيه النص.</li>
<li>الخطوة السابقة للشبكة (RNN Hidden state t-1) التي تمثل المعالجة الناتجة عن الكلمات السابقة يتم معالجتها من خلال مصفوفة اخرى a(t-1) حيث يكون هدفها تعلم ما يجب ان يتم اضافته من الخطوات السابقة و ما يجب ان يتم ازالته.</li>
<li>يتم الجمع بين الخطوتين 2 و 3 و معالجتهم من خلال مرحلة غير خطية تمثلها هنا الدالة tanh و ينتج عنها متجه يعبر عن حالة/فهم الشبكة للنص حتى هذه اللحظة (RNN Hidden state t).</li>
</ol>
</div>

<p><img src="/assets/images/intro-to-nlp-p2/inside-rnn-1.png" alt="inside-rnn-1" class="align-center" /></p>
<center><div dir="rtl">معالجة الكلمة الاولى من النص (Very)</div></center>
<p><br /></p>

<div dir="rtl">
ثم يتم تكرير الخطوات السابقة باستخدام نفس المصفوفات X(t) و a(t-1) مع الكلمة التالية كما هو موضح بالشكل الاتي
</div>

<p><img src="/assets/images/intro-to-nlp-p2/inside-rnn-2.png" alt="inside-rnn-2" class="align-center" /></p>
<center><div dir="rtl">معالجة الكلمة الثانية من النص (good)</div></center>

<p><br /></p>

<div dir="rtl">
هذه العملية تسمح للشبكة بعد التدريب و تعديل قيم متغيراتها باستخدام النزول التدريجي و تصحيح اخطائها بان تتعلم القيم المناسبة للمصفوفات الخاصة بها لكي تستطيع تعلم النص بشكل يناسب المسئلة التي نقوم بحلها.
</div>

<h3 class="text-right" id="الشبكة-التكرارية-ذات-الابواب-gated-recurrent-unit">الشبكة التكرارية ذات الابواب (Gated Recurrent Unit)</h3>

<div dir="rtl">
الوصف السابق للشبكة التكرارية يعاني من مشكلة اساسية و هي ان مع طول النص سيكون من الصعب على الشبكة تذكر ما كان في بداية الجملة لان كما نرى في آلية العمل هنا ان الكلمة الحالية و الحالة السابقة لديهم قدرة كبيرة على تغيير حالة الشبكة ولا يوجد آلية للابقاء على المعلومات السابقة في النص.
</div>

<div dir="rtl">
لذا تم استحداث نموذج معدل من الشبكة التكرارية هو الشبكة التكرارية ذات الابواب (Gated Recurrent Unit GRU) و هي كما يقول الاسم عبارة عن شبكة تكرارية ولكن مع اضافة بوابات، تقوم هذه البوابات بالسماح للشبكة بالحفاظ على معلومات من خطوات سابقة عن طريق تعلم مجموعة متغيرات جديدة تكون البوابة التي تتحكم في مرور او عدم مرور المعلومات الناتجة من الكلمة الحالية و الكلمات السابقة كما هو موضح بالشكل الاتي.
</div>

<p><img src="/assets/images/intro-to-nlp-p2/gru-1.png" alt="gru-1" class="align-center" /></p>
<center><div dir="rtl">GRU</div></center>

<div dir="rtl">
لفهم اعمق لما يحدث هنا دعنا نلقي نظرة على المعادلات لهذا المجسم
</div>

\[\tilde{C} = tanh(W_c [C^{t-1}, X^t] + b_c)\]

<div dir="rtl">
هذه المعادلة تمثل الشبكة التكرارية العادية (Vanilla RNN)
</div>

\[\Gamma_u = \sigma(W_u [C^{t-1}, X^t] + b_u)\]

<div dir="rtl">
هنا يتم تعلم البوابة التي تتحكم في مرور المعلومات من الكلمة الجديدة و الكلمات السابقة، و كما ترى هنا فهي معادلة تعتمد على الكلمة الحالية Xt و الحالة السابقة للشبكة C(t-1)
</div>

<p><img src="/assets/images/intro-to-nlp-p2/gru-2.png" alt="gru-2" class="align-center" /></p>
<center><div dir="rtl">عند هذه النقطة لدينا المتجه Ct الذي يعبر عن الحالة الجديدة من الكلمة الحالية و كذلك المتجه r الذي سوق يستخدم كبوابة للتحكم في مرور المعلومات</div></center>

\[C^t = \Gamma_u*\tilde{C} + (1-\Gamma_u)* C^{t-1}\]

<div dir="rtl">
لتكوين الحالة الجدية للشبكة Ctتقوم البوابة في التحكم في مرور المعلومات من الخطوة السابقة و الخطوة الحالية حيث كما نرى الجزء الاول r*C يتحكم في مرور المعلومات من الخطوة الحالية و الجزء الثاني (1-r)*C(t-1) يتحكم في مرور المعلومات من الخطوة السابقة.
</div>

<div dir="rtl">
لاحظ هنا ان البوابة r تنتج من دالة sigmoid اي ان قيمها ستكون من 0 ل 1 بالتالي يمكنك التفكير فيها على انها تمنع قيم و تمرر قيم كما ترى في الشكل التالي.
</div>

<p><img src="/assets/images/intro-to-nlp-p2/gru-3.png" alt="gru-3" class="align-center" /></p>
<center><div dir="rtl">ما يتم ازالته من متجه يتم تعويضه من المتجه الاخر</div></center>

<div dir="rtl">
تسمح هذه المعمارية بالاحتفاظ بمعلومات سابقة على عكس الشبكة التكرارية التقليدية، لهذا يمكنها معالجة نصوص اطول.
</div>

<h3 class="text-right" id="الشبكة-ذات-الذاكرة-الطويلة-و-القصيرة-المدى-long-short-term-memory---lstm">الشبكة ذات الذاكرة الطويلة و القصيرة المدى (Long Short Term Memory - LSTM)</h3>

<div dir="rtl">
استخدام البوابات في التحكم في مرور المعلومات يسمح للشبكة بتعلم النصوص الطويلة نسبيا و على غرار الشبكة ذات البوابات تم ايضا بناء نوع اخر من الشبكة التكرارية و هي الشبكة ذات الذاكرة الطويلة و القصيرة المدى (Long Short Term Memory - LSTM)، و تقوم هذا المعمارية بإضافة اكثر من بوابة للتحكم في مرور المعلومات و تعمل على اضافة ذاكرة طويلة المدى للحفاظ على المعلومات القديمة و كذلك ذاكرة قصيرة للتعبير عن المعلومات القريبة في النص.
</div>

<div dir="rtl">
المبدأ المستخدم في الشبكة ذات الذاكرة لايختلف كثيرا عن ذات البوابات، حيث يوجد في الشبكة ذات الذاكرة ثلاث بوابات.
</div>

<div dir="rtl">
<ul>
<li><b>بوابة النسيان (Forget Gate)</b> تتحكم فيما يتم ازالته او اضافته على الذاكرة الطويلة السابقة (اي الذاكرة الطويلة الناتجة من الخطوة الزمنية السابقة)</li>
<li><b>بوابة التحديث (Update Gate)</b> تتحكم فيما يتم ازالته او اضافته على الذاكرة الطويلة الجديدة (اي الذاكرة الطويلة التي سوف تنتجها الخطوة الزمنية الحالية)</li>
<li><b>بوابة النتيجة (Output Gate)</b> تتحكم في الذاكرة قصيرة المدى الناتجة من الخلية الحالية</li>
</ul>
</div>

<p><img src="/assets/images/intro-to-nlp-p2/lstm-1.png" alt="lstm-1" class="align-center" /></p>
<center><div dir="rtl">Long Short Term Memory</div></center>

<p><br /></p>

<div dir="rtl">
تعمل البوابات بشكل مشابه لما سبق شرحه، ها هي المعادلات لفهم افضل لما يحدث.
</div>

<p><br /></p>

<p class="text-right">بوابة النسيان</p>

\[\Gamma_f = \sigma(W_f [a^{t-1}, x^t] + b_f)\]

<p class="text-right">بوابة التحديث</p>

\[\Gamma_u = \sigma(W_u [a^{t-1}, x^t] + b_u)\]

<p class="text-right">بوابة النتيجة</p>

\[\Gamma_o = \sigma(W_o [a^{t-1}, x^t] + b_o)\]

<p class="text-right">الذاكرة المقترحة C~</p>

\[\tilde{C} = tanh(W_c [a^{t-1}, x^t] + b_c)\]

<p class="text-right">الذاكرة طويلة المدى</p>

\[C^t = \Gamma_u*\tilde{C} + \Gamma_f*C^{t-1}\]

<div dir="rtl" class="notice--info">
لاحظ هنا ان الذاكرة الطويلة الجديدة يتم تكوينها عن طريق الذاكرة الطويلة للخطوة السابقة بعد تمريرها على بوابة النسيان  اضافة الي الذاكرة الجديدة المقترحة بعد تمريرها على بوابة التحديث، وهذا يسمح للشبكة بالتحكم فيما يتم تمريره من الذاكرة السابقة و ما يتم تمريره من الذاكرة المقترحة.
</div>

<p class="text-right">الذاكرة قصيرة المدى</p>

\[a^t = \Gamma_o*tanh(C^t)\]

<h3 class="text-right" id="تعديلات-الشبكة-التكرارية">تعديلات الشبكة التكرارية</h3>

<div dir="rtl">
كأي شبكة عصبية يمكننا اضافة اكثر من طبقة من نفس النموذج لزيادة تعقيد النموذج و بالتالي تمكينه من تعلم انماط اكثر تعقيدا و لكن الشبكة التكرارية بطبيعة الحال تعاني من كونها تكرارية و يجب على كل الكلمات ان تمر بالشبكة كلمة تلو الاخرى مما يعني ان لمعالجة الكلمة الثانية في الطبقة الثانية من الشبكة يجب على كل الكلمات السابقة في نفس الطبقة ان تكون انتهت من المعالجة و كذلك كل الكلمات السابقة في الطبقات السابقة لها مما يجعل من الصعب تحقيق اقصى استفادة من الموارد المتاحة لتدريب نماذج اكبر. 
</div>

<p><br /></p>

<p><img src="https://static.packt-cdn.com/products/9781787121089/graphics/image_06_008.png" alt="2-layer-rnn" class="align-center" /></p>
<center><a href="https://subscription.packtpub.com/book/big_data_and_business_intelligence/9781787121089/6/ch06lvl1sec70/setting-up-a-deep-rnn-model">المصدر</a></center>

<p><br /></p>

<div dir="rtl">
يمكننا ايضا جعل الشبكة التكرارية ترى في الاتجاهيين، بمعنى ان في اي لحظة زمنية يمكن للشبكة معرفة الكلمات السابقة و الكلمات القادمة و هذا يمكن ان يكون مفيد للغاية في تطبيقات مثل التعرف على الاسماء المعرفة (NER) على سبيل المثال، و يسمى هذا النوع من الشبكة بالشبكة التكرارية ثنائية الاتجاه (Bi-Directional RNN).
</div>

<div dir="rtl">
لتحقيق هذا يمكننا استخدام شبكتين تكراريتين، واحدة تعالج النص من اليمين لليسار و الاخرى تقوم بالعكس، وعند معالجة الكلمة نستخدم مجموع ما تعلمته الشبكة و الاولى و الشبكة الثانية مما يضيف ثراء معلوماتي للكلمة.
</div>

<p><br /></p>

<p><img src="https://miro.medium.com/max/764/1*6QnPUSv_t9BY9Fv8_aLb-Q.png" alt="bi-directional-rnn" class="align-center" /></p>
<center><a href="http://colah.github.io/posts/2015-09-NN-Types-FP/">المصدر</a></center>

<div dir="rtl" class="notice--info">
لاحظ هنا ان كل شبكة لاترى النص ككل و انما تراه جزء فقط، اي ان الشبكة التي تعمل من اليسار لاترى الا الكلمات السابقة لها ولا ترى الكلمات التي سوف تأتي لاحقأ وكذلك الشبكة التي تعمل من اليمين لاترى الا الكلمات يمينها ولا ترى الكلمات في اليسار، لذلك يعتبر استخدام النموذج ثنائي الاتجاه تحايل على رؤية النص كله ولكن فعليا هذا لايحدث هنا بشكل كامل.
</div>

<h3 class="text-right" id="حدود-الشبكة-التكرارية">حدود الشبكة التكرارية</h3>

<div dir="rtl">
بسبب طبيعتها التكرارية كما ذكرنا من قبل فان الشبكة التكرارية تعاني عدم القدرة على الاستغلال الأمثل للموارد بمعنى انه لا يمكننا تدريب طبقات هذه الشبكة بالتوازي لان الخطوات الزمنية تعتمد على بعضها البعض لذا يجب على كل خطوة انتظار الخطوة السابقة لها مما يمنع تدريبها بشكل متوازي.
</div>

<div dir="rtl">
ايضا الشبكة لا تر النص بشكل كامل كما ذكرنا حتى مع استخدام ثنائية الاتجاه لان كما ذكرنا كل شبكة ترى فقط الكلمات السابقة على حسب اتجاهها.
</div>

<div dir="rtl">
وعلى الرغم من استخدام البوابات و الذاكرة للاحتفاظ بالمعلومات الا انه من الصعب الاحتفاظ بكل المعلومات مع طول النص المعالج لذلك يتم فقد جزء من معلومات النص.
</div>

<h2 class="text-right" id="الاستنتاج">الاستنتاج</h2>

<div dir="rtl">
في هذا المقال تحدثنا عن مبدأ ال word embeddings او تمثيل النصوص باستخدام متجهات تعبر عن المعنى و التي كانت قفزة كبيرة في عالم معالجة اللغة و ايضا تكلمنا عن طريقة عملها و طرق مختلفة في تطبيقها.
</div>

<div dir="rtl">
تناولنا ايضا استخدام معماريات مختلفة مثل CNN و LSTM و كيفية عملهم و الصعوبات التي تواجه بعض النماذج.
</div>

<div dir="rtl">
في المقال القادم سوف نتعرض لمعماريات (architectures) جديدة استطاعت ان تتغلب على ما سبقها في عدة مهام مما جعلها احدث ما ورد في المجال (State of the Art) حتى تاريخ كتابة هذا المقال 
</div>

<div dir="rtl" class="notice--success">
في هذا المقال حاولت تبسيط بعض المصطلحات للغتنا العربية من اجل تسهيل عملية الشرح ولتبسيط المعلومة، في حالة اي خطأ املائي او اقتراح افضل للترجمة فأنا ارحب جدا بذلك يمكنك التعليق على المقال او مراسلتي لتعديل و تحسين المحتوى، ووفقنا الله وإياكم لما يحب ويرضى.
</div>

<h2 class="text-right" id="مصادر">مصادر</h2>

<div dir="rtl">
<ul>
<li><a href="https://arxiv.org/abs/1301.3781">الورقة البحثية لنموذج word2vec</a></li>
<li><a href="https://www.coursera.org/learn/nlp-sequence-models">كورس Sequence Models من deeplearning.ai</a></li>
</ul>
</div>]]></content><author><name>Ali Abdelaal</name></author><category term="Blog" /><category term="arabic" /><category term="natural language processing" /><category term="machine learning" /><summary type="html"><![CDATA[نظرة عامة في مجال معالجة اللغة باستخدام خوارزميات تعلم الآلة الجزء الثاني]]></summary></entry><entry><title type="html">Permutations and Combinations in Arabic</title><link href="/blog/permutations-and-combinations/" rel="alternate" type="text/html" title="Permutations and Combinations in Arabic" /><published>2020-08-16T00:00:00+00:00</published><updated>2020-08-16T00:00:00+00:00</updated><id>/blog/permutations-and-combinations</id><content type="html" xml:base="/blog/permutations-and-combinations/"><![CDATA[<script src="https://formspree.io/js/formbutton-v1.min.js" defer=""></script>

<script>
   window.formbutton=window.formbutton||function(){(formbutton.q=formbutton.q||[]).push(arguments)};
   formbutton("create", {
     title: "Hello there 👋",
     description: "Subscribe for my new content, or drop a message 🥳",
     action: "https://formspree.io/xbjzaerk",
     theme: "classic",
     fields: [{
      name: "name",
      type: "text",
      label: "Your Name",
      required: true,
      placeholder: "Say your name 🤔"
    },
    {
      name: "email",
      type: "email",
      label: "Your Email",
      placeholder: "Enter your em@il 📬",
      required: true
    },
    {
      name: "Message",
      type: "textarea",
      placeholder: "drop a message ! 🤓 if you want to 🤷‍♂️"
    },
    {
      type: "submit"
    }],
     })
</script>

<h2 class="text-right" id="مقدمة">مقدمة</h2>

<div dir="rtl">
اغلبنا يتذكر مصطلح التباديل و التوافيق من المدرسة، غالبا نتذكر الاسم فقط و ننسى ما الفارق بينهم او غالبا ننساهم بالكلية، في هذا المقال سوف نقوم بتبسيط المعلومة حتى تصبح سهلة الاسترجاع فلا نضطر لحفظ المعادلات بعد الان لنعلم على سبيل المثال ما عدد كلمات المرور الممكنة في القفل الموجود بالصورة.
</div>

<p><img src="/assets/images/permutations-and-combinations/lock.png" alt="lock" class="align-center" /></p>
<center><a href="https://unsplash.com/">المصدر</a></center>

<h2 class="text-right" id="العدّ">العدّ</h2>

<div dir="rtl">
العدّ هو اساس العمليات الحسابية، و هو ببساطة اننا نريد معرفة عدد معين من الاشياء دون ان نضطر ان نقوم بعدّهم واحد بواحد، و هذه العملية مهمة في كثير من التطبيقات العملية، ابسطها معرفة عدد الخطوات التي يحتاجها برنامج معين حتى يقوم بعمل مهمة ما، وكذلك لحساب المساحة التي يمكن ان تشغلها عملية معينة قبل تنفيذها.
</div>

<div dir="rtl">
فعلى سبيل المثال في هذه الصورة التي امامك هل يمكنك معرفة كم عدد الكرات دون ان تقوم بعّدهم واحدة تلو الاخرى ؟
</div>

<p><img src="/assets/images/permutations-and-combinations/counting.png" alt="counting" class="align-center" /></p>

<div dir="rtl">
بالتأكيد يمكنك ذلك عن طريق حساب عدد الصفوف و الاعمدة ثم حساب حاصل ضربهم ليكون الناتج هو عدد الكرات، وهكذا يكون ابسط مثال للعّد بدون الحاجة لعّد الامثلة واحدة تلو الاخرى ولكن هذه العملية لن تفلح في جميع الحالات، دعنا نرى كيف.
</div>

<div dir="rtl">
فلنفرض على سبيل المثال في موقعك الالكتروني لديك مجموعة فيديوهات و فئات مختلفة، مثل كوميديا، اكشن وهكذا، و لنقل ان الموقع يحتوي على 5 فيديوهات في فئة ما و 7 في فئة اخرى، فهل هذا يعني ان هناك 12 مقطع فيديو على موقعك ؟
</div>

<div dir="rtl">
ليس بالضرورة بالتأكيد لان الفيديو قد يقع في فئتين في نفس الوقت، مثل ان يكون كوميدي و اكشن مثلا، اذا لا يمكننا هنا ان نقوم بضرب عدد الفئات في الافلام كما فعلنا في مثال الكرات بالسابق ولكن نحتاج إلى حساب عدد الفيديوهات الموجودة فقط في الفئة الاولى و كذلك الفئة الثانية و نزيل الفيديوهات المكررة حتى لا نعدّها مرتين لعمل هذا نحتاج الى استخدام المجموعات، هل تتذكرها ؟
</div>

<h2 class="text-right" id="المجموعات">المجموعات</h2>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3e/Venn_0000_0001.svg/320px-Venn_0000_0001.svg.png?1597616693654" alt="sets" class="align-center" /></p>
<center><a href="https://www.wikiwand.com/en/Intersection_(set_theory)">المصدر</a></center>

<div dir="rtl">
المجموعات هي عبارة عن مجموعة ارقام (او غير ارقام ولكن تركيزنا سيكون على الارقام)، لا يهم ترتيبهم ولا تكررارهم لان المجموعة هي الارقام المميزة فيمكننا القول بأن
</div>

\[\left \{1,1,1,2,3,3,4 \right \} = \left \{1,2,3,4 \right \}\]

<div dir="rtl">
هذا لان التكرار لا يهمنا هنا، وبالتالي يمكننا حساب تقاطع و اتحاد المجموعات، فان الاتحاد هو كل الارقام الموجودة في المجموعتين و التقاطع هي الارقام المشتركة كما تتذكر و يرمز لهم كما يلي.
</div>

\[A = \left \{1, 2, 3, 4, 5 \right \}\]

\[B = \left \{1, 3, 5, 7 \right \}\]

\[A \cap B = \left \{1, 3, 5 \right \} \rightarrow 1\]

\[A \cup B = \left \{1, 2, 3, 4, 5, 7 \right \} \rightarrow 2\]

<div dir="rtl">
نرى في المعادلة الاولى تقاطع المجموعتين و في المعادلة الثانية اتحادهما، يمكننا ايضا التعبير عن عدد العناصر في المجموعة كما يلي
</div>

\[A = \left \{1, 4, 6 \right \}\]

\[\left | A \right |  = 3\]

<div dir="rtl">
اذا بالعودة إلى مثال الافلام في موقعك الذي تحدثنا عنه من قبل يمكننا صياغة المجموع بأنه مجموع الافلام في المجموعة الاولى و المجموعة الثانية طرح تقاطعهما كما في المعادلة الآتية
</div>

\[\left | A \cup  B  \right | = \left | A \right | + \left | B \right | - \left | A \cap B  \right |\]

<div dir="rtl">
و يمكننا استخدام هذا القانون في العدّ بصورة عامة اذ اننا نقوم بعدّ كل مجموعة ثم نقوم بطرح التقاطع الذي يمثل الارقام التي قمنا بحسابها بالفعل مرة في مجموعة من المجموعات.
</div>

<h2 class="text-right" id="قاعدة-الضرب">قاعدة الضرب</h2>

<div dir="rtl">
جميعنا نعلم قاعدة الضرب ولكن دعنا نتخيلها سويا، لنقل ان لدينا 3 طلاب و ان هناك 5 امتحانات، اذا كم درجة لدينا ؟
</div>

<p><img src="/assets/images/permutations-and-combinations/table.png" alt="table" class="align-center" /></p>

<div dir="rtl">
بالتأكيد النتيجة 15 لان هذا حاصل الضرب، لان لكل طالب هناك نتيجة في امتحان ما، اي ان مجموعة الطلاب المكونة من 3 كل طالب فيهم اصبح لديه مجموعة من الدرجات، و بالتالي اصبح لدينا ازواج من الطلاب و الدرجات كل زوج يمثل طالب ما و درجة امتحان ما، لهذا قمنا بحساب ضرب الطلاب و الدرجات!
</div>

<h2 class="text-right" id="كم-كلمة-سر-يمكن-تكوينها-باستخدام-القفل">كم كلمة سر يمكن تكوينها باستخدام القفل</h2>

<p><img src="/assets/images/permutations-and-combinations/lock.png" alt="lock" class="align-center" /></p>
<center><a href="https://unsplash.com/">المصدر</a></center>

<div dir="rtl">
باستخدام قاعدة الضرب كيف يمكننا حساب عدد كلمات السر التي يمكن تكوينها باستخدام هذا القفل ياترى؟، دعنا نرى كيف
</div>

<p><img src="/assets/images/permutations-and-combinations/comb-pass.png" alt="comb-lock" class="align-center" /></p>

<div dir="rtl">
كما ترى، يمكننا في كل خانة ان نختار رقم من 0 الى 9، اذا عشرة ارقام في الخانة الاولى و مثلهم في الخانة الثانية و الثالثة و بهذا نقوم بحساب حاصل ضرب 10 × 10 × 10 و نحصل بالتالي على 1000 كلمة مرور يمكن تمثيلها بهذا القفل.
</div>

<div dir="rtl">
يمكن استخدام هذه الطريقة لحساب عدد العمليات التي يتطلبها برنامج لكسر كلمة مرورك على سبيل المثال، اذ انه يمكننا كما رأيت ان نستخدم هذه العملية بناءا على ما سبق و نقول انه يتطلب منك على اقصى تقدير 1000 عملية تخمين قبل ان تقوم بكسر شيفرة القفل بالأعلى هذا ان كان فقط يحتوي على ارقام، هل يمكنك التخمين الآن لماذا نستخدم ارقام و حروف ورموز ككلمة مرور ؟
</div>

<div dir="rtl">
يمكننا استنتاج قاعدة بسيطة هنا يمكن استخدامها في مواضع كثيرة و هي ما هي الاشكال التي يمكن الحصول عليها من متسلسلة من عدة رموز بمعلومية الرموز المتاحة، على سبيل المثال، في التعداد الثنائي (Binary numbering system) المستخدم في الدوائر الالكترونية، كم رقم يمكنك الحصول عليه اذا كان لديك 8 اماكن، و كل مكان يمكن ان يحمل قيمة من اثنين اما 0 او 1
</div>

<p><img src="/assets/images/permutations-and-combinations/binary.png" alt="binary-comb" class="align-center" /></p>

<div dir="rtl">
و هنا يمكننا استخدام القاعدة و هي ان مجموع الارقام التي يمكننا الحصول عليها هي عدد الرموز الممكنة أُس عدد الاماكن المتاحة، بالتالي في مثالنا هنا سيكون محصلة الارقام المتاحة هي
</div>

\[2 \times 2 \times 2 \times 2 \times 2 \times 2 \times 2 \times 2 = 2^8 = 256\]

<h2 class="text-right" id="مجموعات-بشروط">مجموعات بشروط</h2>

<div dir="rtl">
لننظر إلى مشكلة اخرى اكثر تعقديا ونرى كيف يمكن حلها باستخدام قاعدة الضرب و بدون الحاجة إلى عد جميع الاحتمالات
</div>

<div dir="rtl">
من بين الارقام 0 و 9999، كم رقم يمكننا الحصول عليه يحتوي على الرقم 7 مرة واحدة فقط به مثل 1117 و ليس مثلا 1717 لابد من وجود 7 مرة واحدة فقط ؟
</div>

<p><img src="/assets/images/permutations-and-combinations/permute.gif" alt="7-permute" class="align-center" /></p>

<div dir="rtl">
لنحل هذه المسألة دعنا نفكر بها بنفس الطرق السابقة، في البداية يمكننا استخدام الرقم 7 في الخانة الاولى و هذا يعطي جميع الخانات الاخرى الاختيار بين اي رقم ماعدا ال 7 هكذا يصبح لدينا 9 اختيارات من 0 إلى 6 و 8 و 9، وبهذا يصبح مجموع الارقام الممكنة مع وجود 7 واحدة فقط في البداية هي
</div>

\[9 \times 9 \times 9 = 729\]

<p><img src="/assets/images/permutations-and-combinations/permute-7-1.png" alt="permute-7-1" class="align-center" /></p>

<div dir="rtl">
اذا بهذا الشكل فقط يمكننا الحصول على 729 رقم، ولكن الرقم 7 يمكنه ان يكون في اي مكان من ال 4 اماكن، وفي جميع الحالات سيكون مجموع الارقام الممكنة هي 729، اذا فإن محصلة الارقام التي يمكننا الحصول عليها و تحتوي الرقم 7 مرة واحدة فقط هي.
</div>

\[729 \times 4 = 2916\]

<h2 class="text-right" id="التباديل-permutations">التباديل Permutations</h2>

<div dir="rtl">
والآن لموضوعنا الرئيسي و هو التباديل، ولكن ما هي التباديل على اية حال؟، دعنا نرى مثال على التباديل لنفهم تعريفها بشكل افضل.
</div>

<div dir="rtl">
فلنفرض ان اسمك هو "علي"، كم كلمة يمكننا كتابتها باستخدام حروف اسمك بدون استخدام نفس الحرف مرتين ؟
<br />
الكلمات على سبيل المثال "يلع" او "يعل" وهكذا، اذا كم كلمة يمكنك الحصول عليها ؟
</div>

<div dir="rtl">
في هذا المثال اسمك يتكون من 3 احرف، اذا في اول حرف لديك حرية الاختيار بين ايا منهم، اذا اول حرف يحمل 3 احتملات {ع, ل, ي}، ثم نأتي للحرف الثاني، سيكون امامك احتمالين فقط من الحروف اذ ان الحرف الذي تم اختياره من قبل المكان الاول لا يمكن اختياره الان لذا لديك فقط اختيارين، وهذا يترك اختيار واحد فقط للمكان الاخير و هذا يعطينا عدد من الكلمات يساوي 3 × 2 × 1 و بهذا يمكننا الحصول على 6 كلمات باستخدام حروف اسمك، دعنا نرى المثال بصورة اوضح.
</div>

<div dir="rtl">
لنقل ان في المكان الاول اخترنا الحرف "ي" اذا في المكان الثاني لدينا فقط الحروف {ع, ل} لنختار منهم، و اذا اخترنا الحرف "ع" على سبيل المثال سيتبقى للمكان الاخير حرف واحد فقط للاختيار و هو حرف "ل"
</div>

<div dir="rtl">
يمكننا تعميم هذه الحالة كما يلي، في حالة ان لديك عدد رموز n للاختيار منهم (على سبيل المثال الحروف الابجدية مثلا) و نريد تكون مجموعة طولها k رمز (مثل ان تكون الكلمة من 3 احرف مثلا) فإن مجموع الكلمات التي يمكنك الحصول عليها هو
</div>

\[n \times (n-1) \times (n-2) ... (n-k+1) = \frac{n!}{(n-k)!}\]

<div dir="rtl">
لاحظ ان في حالة ان n=k سيكون المقام بصفر، ولكن نفرض ان مضروب 0 = 1 وبهذا اذا كانت n=k فان مجموع التباديل هو n!
<br />
لنرى مثال على هذا، اذا كان لديك 5 كتب، وتريد ان تعرف كم طريقة يمكنك ترتيبهم بها على ارفف مكتبتك، كم طريقة يمكنك ترتيبهم بها ؟
</div>

<p><img src="https://unsplash.com/photos/t6oZEgL0z18/download?force=true&amp;w=640" alt="book-shelf" class="align-center" /></p>
<center><a href="https://unsplash.com/">المصدر</a></center>

<div dir="rtl">
لتوضيح المثال كما فعلنا من قبل، في اول مكان يمكننا الاختيار من الكتب كلها، في ثاني مكان سنختار من الكتب كلها ماعدا الذي قمنا بإختياره، وهكذا مع كل خطوة تقل اختياراتك حتى تنهي الكتب و بهذا يصبح عدد الطرق التي يمكنك ترتيب كتبك بها هي
</div>

\[n \times (n-1) \times (n-2) ...(n-n+1) = n! = 5! = 120\]

<div dir="rtl">
اذا يمكنك ترتيب الكتب ب 120 طريقة كما ترى
</div>

<h2 class="text-right" id="التوافيق-combinations">التوافيق Combinations</h2>

<div dir="rtl">
لنقل ان لدينا 5 كرات و نريد ان نعرف كم مجموعة يمكننا تكوينها باستخدام 3 كرات بدون تكرار ايا من المجموعات، دعنا نرى تفاصيل هذا العملية
</div>

<p><img src="/assets/images/permutations-and-combinations/combinations-1.png" alt="combinations-1" class="align-center" /></p>

<div dir="rtl">
هنا يمكنك تن ترى اننا قمنا بتثبيت الكرة الاولى و اخترنا على اساسها باقي الكرات، لنرى عندما نقوم بتثبيت الكرة الثانية ماذا سيحدث
</div>

<p><img src="/assets/images/permutations-and-combinations/combinations-2.png" alt="combinations-2" class="align-center" /></p>

<div dir="rtl">
يمكنك ان ترى هناك عدة مجموعات متكررة مثل {1, 2, 3} و ايضا {1, 2, 4} بالتالي اذا قمنا بعمل حساباتنا مثل التبادل سوف نجد ان هناك العديد من التكرار بها، ونحن نريد حساب فقط العمليات المميزة، اذا كيف يمكننا ذلك ؟
</div>

<div dir="rtl">
في مثالنا السابق اردنا اختيار مجموعات مكونة من 3 كرات من اصل 5 كرات، و اذا قمنا بحساب مجموع عدد المجموعات التي يمكننا تكوينها بما في ذلك مرات التكرار سنجد ان مجموعهم هو
</div>

\[5 \times (5-1) \times (5-2) = \frac{5!}{(5-3)!} = 60\]

<div dir="rtl">
والان دعنا نحسب عدد مرات التكرار التي يمكن ان تظهر في مجموعاتنا، بما ان كل مجموعة تتكون من 3 كرات، اذا فيمكننا تحويلها لنفس نمط عدد الكلمات التي يمكنك تكوينها باستخدام حروف اسم "علي" هذا لان الكرات مثلا {1, 2, 3} يمكن ايضا ان تظهر بشكل {2, 1, 3} وبهذا يصبح لديك نفس المجموعة ولكن فقط ترتيبها مختلف، اذا يمكننا ان نحسب كم شكل يمكن تكوينه من كل مجموعة و نقوم بقسمة التباديل عليه و بالتالي سنحصل على المجموعات و لكن بدون المجموعات المكررة ونحصل على المعادلة الآتية لحساب التوافيق
</div>

\[\binom{n}{k} = \frac{n!}{k! (n-k)!}\]

<div dir="rtl">
لاحظ ان الاقواس تعني كم مجموعة مميزة طولها k يمكننا ان نحصل عليها من مجموعة مكونة من n عنصر.
</div>

<div dir="rtl">
بتطبيق هذه العملية على مثالنا يمكننا ان نحصل على عدد المجموعات المميزة و هو كما يلي
</div>

\[\binom{5}{3} = \frac{5!}{3! (5-3)!} = 10\]

<div dir="rtl">
اذا يمكننا فقط الحصول على 10 مجموعات مميزة من الكرات الخمس اذا كان طول المجموعة 3
</div>

<h2 class="text-right" id="كيفية-استخدام-التباديل-و-التوافيق-في-لغة-البايثون">كيفية استخدام التباديل و التوافيق في لغة البايثون</h2>

<div dir="rtl">
الان دعنا نرى كيف يمكننا ان نستخدم هذه القواعد في لغة ال Python للحصول على تباديل و توافيق من مجموعة ارقام list على سبيل المثال
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">permutations</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">my_permutations</span> <span class="o">=</span> <span class="n">permutations</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
<span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">my_permutations</span><span class="p">:</span>
  <span class="k">print</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
<span class="o">&gt;&gt;&gt;</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
<span class="o">&gt;&gt;&gt;</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
<span class="o">&gt;&gt;&gt;</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span class="o">&gt;&gt;&gt;</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
<span class="o">&gt;&gt;&gt;</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">...</span>
</code></pre></div></div>

<div dir="rtl">
يمكنك ايضا الحصول على جميع التباديل مرة واحدة بدون الحاجة لاستخدام for loop كما يلي
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">permutations</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">my_permutations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">permutations</span><span class="p">(</span><span class="n">numbers</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">my_permutations</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">120</span>
</code></pre></div></div>

<div dir="rtl">
و الان لنرى كيف يمكننا ان نحصل على التوافيق بمثال الكرات الخمس الذي استخدمناه سابقا
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="c1"># 3 here represents K in our example
</span><span class="n">my_combs</span> <span class="o">=</span> <span class="n">combinations</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">my_combs</span><span class="p">:</span>
  <span class="k">print</span><span class="p">(</span><span class="n">comb</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span class="o">&gt;&gt;&gt;</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
<span class="o">&gt;&gt;&gt;</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
<span class="o">&gt;&gt;&gt;</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
<span class="o">&gt;&gt;&gt;</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
<span class="o">&gt;&gt;&gt;</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
<span class="o">&gt;&gt;&gt;</span>  <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
<span class="o">&gt;&gt;&gt;</span>  <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
<span class="o">&gt;&gt;&gt;</span>  <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
<span class="o">&gt;&gt;&gt;</span>  <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span>
</code></pre></div></div>

<div dir="rtl">
على غرار المثال السابق يمكننا ايضا الحصول عليهم بشكل مباشر
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="c1"># 3 here represents K in our example
</span><span class="n">my_combs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">my_combs</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">10</span>
</code></pre></div></div>

<h2 class="text-right" id="خاتمة">خاتمة</h2>

<div dir="rtl">
في هذا المقال تحدثنا عن التباديل و التوافيق و كيف يمكننا ان نسترجع الفارق بينهم وكيفية حسابهم دون الحاجة الى حفظ المعادلة لان ببساطة يمكنك استرجاع المعلومة و طريقة فهمك لها وبالتالي لا يوجد حاجة لحفظ المعادلات بعد الان هنا.
<br />
تحدثنا عن كيف ان العدّ هو ابسط ولكن من اهم العمليات في الرياضيات و استخداماته كثيرة جدا، و كيف ان التباديل هي جميع الاشكال التي يمكنك الحصول عليها من مجموعة رموز مع امكانية تبديلهم و التوافيق هي التباديل ولكن مع مراعاة عدم تكرار المجموعات بها.
</div>

<div dir="rtl" class="notice--success">
في هذا المقال حاولت تبسيط بعض المصطلحات للغتنا العربية من اجل تسهيل عملية الشرح ولتبسيط المعلومة، في حالة اي خطأ املائي او اقتراح افضل للترجمة فأنا ارحب جدا بذلك يمكنك التعليق على المقال او مراسلتي لتعديل و تحسين المحتوى، ووفقنا الله وإياكم لما يحب ويرضى.
</div>

<h2 class="text-right" id="مصادر">مصادر</h2>

<div dir="rtl">
<ul>
<li><a href="https://www.coursera.org/learn/discrete-math-and-analyzing-social-graphs/">Discrete Math and Analyzing Social Graphs course by National Research University Higher School of Economics</a></li>
</ul>
</div>]]></content><author><name>Ali Abdelaal</name></author><category term="Blog" /><category term="arabic" /><category term="math" /><summary type="html"><![CDATA[التباديل و التوافيق كما لم تراها في المدرسة]]></summary></entry><entry><title type="html">Introduction to NLP in Arabic - part 1</title><link href="/blog/intro-to-nlp-p1/" rel="alternate" type="text/html" title="Introduction to NLP in Arabic - part 1" /><published>2020-06-24T00:00:00+00:00</published><updated>2020-06-24T00:00:00+00:00</updated><id>/blog/intro-to-nlp-p1</id><content type="html" xml:base="/blog/intro-to-nlp-p1/"><![CDATA[<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>

<script>addBackToTop({
  diameter: 56,
  backgroundColor: 'rgb(128, 128, 128)',
  textColor: '#fff'
})</script>

<h2 class="text-right" id="مقدمة">مقدمة</h2>

<div dir="rtl">
في هذا المقال المكون من جزئين سوف نلقي نظرة عامة على مجال معالجة النصوص باستخدام خوارزميات تعلم الآلة وسوف نلقى الضوء على تطور المجال بداية من استخدام الطرق التقليدية في معالجة النصوص مثل استخدام اسلوب (bag of words) التي تعتمد على عدد الكلمات إلى استخدام الطرق الحديثة مثل (word embedding) و كذلك استخدام تقنيات التعلم العميق (deep learning) في تحسين اداء الانظمة الحديثة التي نستخدمها حاليا في معظم المنتجات مثل انظمة الترجمة الآلية، تصحيح النصوص و البحث و غيره من التطبيقات. 
</div>

<h2 class="text-right" id="قبل-ان-تكمل">قبل ان تكمل</h2>

<div dir="rtl">
في هذا المقال سوف نستعرض بعض الأمثلة باستخدام لغة البايثون (Python) لذا انصحك عزيزي ان لم يكن لديك خلفية عنها ان تطلع على كورس بسيط فيها و تعود لتكمل المقال، لن نقوم بالتطرق لمواضيع متقدمة للغاية في اللغة هنا لذا لابأس ان لم تقم باستخدام اللغة منذ فترة، نحتاج فقط الاساسيات هنا.
</div>

<h2 class="text-right" id="تطبيقات-معالجة-اللغة-في-حياتنا-اليومية">تطبيقات معالجة اللغة في حياتنا اليومية</h2>

<div dir="rtl">
يمكنك ان ترى تطبيقات معالجة اللغة بداية من هاتفك المحمول حيث يمكن للوحة المفاتيح ان تقترح عليك الكلمة القادمة بناءا على اسلوبك في الكتابة و كذلك بناءا على طبيعة اللغة و يتم هذا باستخدام عدة اساليب اشهرها استخدام نموذج للغة (language model)، ايضا يمكنك ان ترى جودة محركات البحث الحالية في فهم ما تريده عن طريق النص الذي تقوم بتزويد المحرك به فيمكن للمحرك ان يفهم المعنى الكامن في النص الذي قمت بإدخاله واستدعاء نتائج بحث تماثل المعنى الذي قمت بطلبه و من الآليات التي توفر لك مثل هكذا قدرات استخدام ال (word embedding) و سوف نتعرض لها في مقالنا هنا.
</div>

<div dir="rtl">
ليس فقط على مستوى الافراد يمكننا ان نرى هذه التطبيقات ولكن ايضا على مستوى الشركات، فعلى سبيل المثال بعض الشركات تقوم بعمل تحليل للنصوص على وسائل التواصل لتوفير معلومات عن السوق وعن ما يقوله عملائك عنك على وسائل التواصل، ويوجد شركات قامت بقطع شوط كبير في هذا المجال في وطننا العربي مثل شركة <a href="https://www.crowdanalyzer.com/">crowdanalyzer</a>.
</div>

<div dir="rtl">
ايضا تقوم بعض الشركات بتطبيق معالجة اللغة في بناءا (chat-bots) تقوم بالتواصل معك من خلال خدمة الدردشة (chat) بدلا من التحدث مع احد ممثلي خدمة العملاء، بل ان شركة جوجل قامت بعرض خدمة جديدة تستبدل ممثل خدمة العملاء كليا اذ انك تتحث مع ال (bot) بالصوت وليس فقط من خلال النص كما هو الحال مع ال (chat-bots) التقليدية.
</div>

<!-- Courtesy of embedresponsively.com //-->

<div class="responsive-video-container">
    <iframe src="https://www.youtube-nocookie.com/embed/D5VN56jQMWM" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>
  </div>

<div dir="rtl">
هذه فقط بعض الأمثلة البسيطة ولكن هناك العديد من التطبيقات في حياتنا يمكنك الإطلاع على بعضها من خلال <a href="https://towardsdatascience.com/natural-language-processing-nlp-top-10-applications-to-know-b2c80bd428cb">هذا</a> الرابط
</div>
<blockquote>

</blockquote>

<h2 class="text-right" id="بعض-اشهر-التطبيقات">بعض اشهر التطبيقات</h2>

<div dir="rtl">
في البداية دعنا نستعرض بعض التطبيقات التي نقوم باستخدام معالجة النصوص بها.
</div>

<h3 class="text-right" id="تحديد-نوع-النص-text-classification">تحديد نوع النص (text classification)</h3>

<div dir="rtl">
اشهر التطبيقات هي تحديد نوع النص من بين انواع محددة (text classification) مثل ان نقوم بتحديد ما إذا كان النص بصيغة المدح ام الذم، على سبيل المثال عند عرض مراجعات منتج معين نريد معرفة ما اذا كانت المراجعة ايجابية ام سلبية و هذا التطبيق تحديدا يسمى (sentiment analysis) و هو تحليل للمشاعر، يمكن ايضا ان تتسع الاختيارات فتشمل انواع اخرى مختلفة مثل ان نقوم بتحديد ما اذا كان الخطاب به عنف ام لا او ان نقوم بتحديد الفئة التي ينتمي اليها النص من بين مجموعة فئات كأن يكون ترفيهي او علمي او رياضي على سبيل المثال.
</div>
<div dir="rtl">
فكما ترى استخدامات تحديد النص كثيرة للغاية و منتشرة بشكل كبير جدا و غالبا ما تجد المصادر التعليمية تهتم بها في بداية تعلمك لمجال معالجة اللغة لاهميتها وكذلك سهولة فهمها وتطبيقها.
</div>

<p><img src="https://1.bp.blogspot.com/-zozGrHwAv9A/WNp86wRiPXI/AAAAAAAAC2M/KUsRp9NEKv8QWhdq2YIXNkkkv02IetiUwCLcB/s1600/sentiment.png" alt="text-classification" class="align-center" /></p>
<center><a href="https://blog.vicz.in/2017/03/what-is-sentiment-analysis.html">المصدر</a></center>

<h3 class="text-right" id="الترجمة-الآلية-neural-machine-translation---nmt">الترجمة الآلية (Neural Machine Translation - NMT)</h3>

<div dir="rtl">
احد اشهر التطبيقات التي نستخدمها هي الترجمة الآلية (Neural Machine Translation - NMT) و هي تشرح نفسها إلى حدا كبير، هي ان تقوم الآلة من تلقاء نفسها بترجمة النص بشكل اوتوماتيكي، كما ترى في خدمة <a hre="https://translate.google.com/">ترجمة جوجل</a> على سبيل المثال.
</div>

<p><img src="/assets/images/intro-to-nlp-p1/nmt-google.png" alt="nmt-google" class="align-center" /></p>
<center><a href="www.google.com">المصدر</a></center>

<h3 class="text-right" id="استخراج-اجابة-السؤال-question-answering">استخراج اجابة السؤال (Question Answering)</h3>

<div dir="rtl">
من اشهر التطبيقات ايضا تطبيق الإجابة على الاسئلة واستخراج الإجابة من النص (Question Answering) وفي هنا يكون هدف البرنامج هو استخراج إجابة سؤال معطى من المستخدم من خلال قطعة نصية كما يقوم محرك البحث بإستخراج الإجابة عن سؤالك الذي قمت بكتابته في محرك البحث !
</div>

<p><img src="/assets/images/intro-to-nlp-p1/qa-nile.png" alt="qa-nile" class="align-center" /></p>
<center><a href="www.google.com">المصدر</a></center>

<h3 class="text-right" id="استخراج-اسماء-الكيانات-named-entity-recognition---ner">استخراج اسماء الكيانات (Named Entity Recognition - NER)</h3>

<div dir="rtl">
ايضا من التطبيقات التي يجب ذكرها هو استخراج اسماء الكيانات (Named Entity Recognition - NER) و هنا نقوم باستخراج من النص الاسماء التي تدل على مؤسسات مثلا، عملات او حتى اسماء لاشخاص.
</div>

<p><img src="/assets/images/intro-to-nlp-p1/ner-mawdoo3.png" alt="ner-mawdoo3" class="align-center" /></p>
<center><a href="https://ai.mawdoo3.com/mixed">المصدر</a></center>

<div dir="rtl">
هذه فقط بعض التطبيقات و يوجد تطبيقات اخرى مهمة مثل تلخيص النصوص (text summarization) و استخراج الكلمات التي تشير لنفس الكيان (Coreference Resolution) وايضا تحويل النصوص إلى صوت (text to speech - TTS) و العديد من التطبيقات الأخرى، يمكنك الإطلاع عليهم وعلى احدث ما توصل إليه العلم في هذه المجالات من خلال <a href="http://nlpprogress.com/">هذا الرابط</a>.
</div>

<h2 class="text-right" id="كيف-تعمل-هذه-التطبيقات">كيف تعمل هذه التطبيقات</h2>

<div dir="rtl">
معالجة النصوص تتم بأكثر من طريقة في الحقيقة، بعض الطرق يكون بسيط للغاية ولكنه ذكي إلى حد كبير إذ يعتمد بشكل اساسي على قواعد مسبقة لدى البرنامج ويقوم بتنفيذها، تطبيق بسيط للغاية لهكذا تطبيق يمكن ان يكون في الشات بوت مثلا لرد التحية.
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">random</span>
<span class="n">replies</span> <span class="o">=</span> <span class="p">[</span> <span class="s">'hi my name is bot !'</span><span class="p">,</span>
            <span class="s">'morning how can i help ?'</span><span class="p">,</span>
            <span class="s">'What can i help you with sir ?'</span><span class="p">]</span>

<span class="n">user_input</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"please enter a message"</span><span class="p">)</span>
<span class="k">if</span> <span class="n">user_input</span> <span class="ow">in</span> <span class="p">[</span><span class="s">'hello'</span><span class="p">,</span> <span class="s">'welcome'</span><span class="p">,</span> <span class="s">'hi'</span><span class="p">,</span> <span class="s">'aloha'</span><span class="p">]:</span>
  <span class="k">print</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">choice</span><span class="p">(</span><span class="n">replies</span><span class="p">))</span>
</code></pre></div></div>

<div dir="rtl">
هنا يمكنك ان ترى بوضوح ان في حالة ادخال المستخدم نص مختلف عن الذي كنت تتوقعه فلن يفهم البرنامج ما قام المستخدم بقوله، ولهذا تعتمد طريقة ال (Rule Based) على ان يقوم كاتبها بتغطية تقريبا كل الحالات التي يمكن ان يقولها المستخدم، وقد اعتادت هذه الطريقة ان تستخد في السابق و لازالت تستخدم حتى الآن منفردة في بعض التطبيقات المحدودة و ايضا تستخدم بجانب استخدام تعلم الآلة لتغطية بعض الحالات التي لدينا معرفة مسبقة عنها.
</div>

<div dir="rtl">
و يمكننا معالجة النص باستخدام طريقة التعلم من خلال البيانات، وهذه الطريقة هي الاكثر استخداما حاليا وتشهد تطور كبير بالتبعية لتطور تطبيقات تعلم الآلة (machine learning) و تطبيقات التعلم العميق (deep learning)، وهذه الطريقة هي التي سنقوم بتغطيتها بشئ من التفاصيل في هذا المقال.
</div>

<div dir="rtl">
ما سبق من التطبيقات تعتمد على تمثيل النصوص بشكل ما يسمح بمعالجتها بشكل سريع و ذو كفاءة عالية، و تختلف طريقة تمثيل النصوص من تطبيق لآخر لذا في هذا الجزء من المقال سوف نقوم بالتركيز على تمثيل النص بالنسبة لتطبيق تحديد النص (text classification) لسهولته كما ذكرنا من قبل.
</div>

<div dir="rtl">
ربما تتذكر من <a href="https://aliabdelaal.github.io/blog/intro-to-ml/#%D8%A7%D9%84%D9%86%D8%B2%D9%88%D9%84-%D8%A7%D9%84%D8%AA%D8%AF%D8%B1%D9%8A%D8%AC%D9%8A-gradient-descent">مقالنا السابق</a> عن تعلم الآلة كيفية عمل النزول التدريجي (gradient descent) وكيف انه يقوم بتحديد اوزان لمجموعة متغيرات ثم نقوم بتقدير هذه الاوزان عن طريق حساب مدى الخطأ، يمكنك الرجوع إلى المقال لاسترجاع هذه المعلومة.
</div>

<p><img src="/assets/images/intro-to-ml/formula-2.png" alt="model-formulation" class="align-center" /></p>
<center><a href="https://aliabdelaal.github.io/blog/intro-to-ml/#%D8%A7%D9%84%D9%86%D8%B2%D9%88%D9%84-%D8%A7%D9%84%D8%AA%D8%AF%D8%B1%D9%8A%D8%AC%D9%8A-gradient-descent">قراءة المقال</a></center>

<div dir="rtl">
اذا يجب ان نقوم بإستخراج خصائص لهذا النص تقوم بتوصيفه وتمييزه عن باقي النصوص، ابسط انواع الخصائص التي يمكننا استخراجها من النص هي الكلمات، فدعنا نرى كيف نستخرج الكلمات كخصائص للنص.
</div>

<h2 class="text-right" id="تمثيل-النص-من-خلال-عدد-الكلمات-bag-of-words---bow">تمثيل النص من خلال عدد الكلمات (bag of words - bow)</h2>

<h3 class="text-right" id="استخراج-مكونات-النص-tokenization">استخراج مكونات النص (Tokenization)</h3>

<div dir="rtl">
 يجب التركيز على نقطة مهمة قبل البدأ في استخراج الخصائص من النص و هي تعريف الكلمة، اذ ان تعريف الكلمة مؤخرا اختلف من طريقة لأخرى، لنكون دقيقين اكثر ما هو تعريف الوحدة النصية (token) في النص الذي نعمل عليه، اذا كانت كلمة فيمكن ان تكون كلمة (يحبه) و (احبه) و (تحبه) كلمات مختلفة تمام عن بعضهم البعض، بينما بعض الطرق تقوم بتفكيك الكلمة و جعلها (ي + حب + ه) و (ا + حب + ه) يمكنك ان ترى ما يحدث هنا، نحن نقوم بتفصيل النص و استخراج مكوناته، هذه العملية مهمة اذ انها الاساس لما هو قادم لان كل وحدة (token) ستعتبر خاصية من خصائص النص، اذا فمثالنا السابق عن الحب بدلا من تصبح (يحبه) صفة من صفات النص ستصبح (ي) و (حب) و (ه) من خصائص النص و هكذا عند استخدام اشكال مختلفة من الفعل ستدري ان الأصل حب.
</div>

<div dir="rtl">
لاحظ ان هذه الطريقة لا تقوم باستخراج اساس الكلمة و هي لاتدري ان حب بالضرورة كلمة صحيحة هي تعمل على اساس معين و خطوات معينة يمكنك الإطلاع عليه من خلال <a href="https://mlexplained.com/2019/11/06/a-deep-dive-into-the-wonderful-world-of-preprocessing-in-nlp/">هذا الرابط</a>.
</div>

<h3 class="text-right" id="بناء-قاعدة-الكلمات-vocabulary">بناء قاعدة الكلمات (vocabulary)</h3>

<div dir="rtl">
سوف نعتمد في البداية على طريقة التقسيم على اساس المسافات اي ان الوحدة النصية ستصبح الكلمة التي تأتي بعدها مسافة، لنستطيع تمثيل النصوص باستخدام هذه الخصائص يجب علينا في البداية ان نقوم بتحديد الصفات التي سوف نقوم بتوصيف النص على اساسها، في هذه الحالة الصفات هي الكلمات اذا لنقم بتحديد كل الكلمات التي يمكننا ان نصف النص بناءا عليها و سوف نسميها قاعدة الكلمات (Vocabulary) او القاموس الخاص بالنموذج الخاص بنا.
</div>

<div dir="rtl">
دعنا نرى مثال باستخدام مكتبة sklearn في لغة البايثون.
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="kn">import</span> <span class="n">CountVectorizer</span>

<span class="n">text</span> <span class="o">=</span><span class="p">[</span>
    <span class="s">"مرحبا"</span><span class="p">,</span>
    <span class="s">"اهلا يا صديقي"</span><span class="p">,</span>
    <span class="s">"كيف حالك يا صديقي"</span><span class="p">,</span>
    <span class="s">"مرحبا صديقي"</span>
<span class="p">]</span>

<span class="n">vectorizer</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">()</span>
<span class="n">vectorizer</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/intro-to-nlp-p1/count-vectorizer.png" alt="count-vectorizer" class="align-center" /></p>

<div dir="rtl">
كما ترى هنا قاعدة الكلمات الخاصة بنا هي الكلمات المميزة في جميع النصوص و يتم توصيف النص من خلال عدد الكلمات التي تظهر به، فعلى سبيل المثال يمكن ان نرى هنا ان النص "مرحبا يا صديقي" يتم تمثيله بالارقام
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<div dir="rtl">
تعد هذه الطريقة الابسط في تمثيل النصوص و يمكن استخدامها كممثل للنص كما نرى و في المثال القادم نقوم بعمل نموذج بسيط باستخدام sklearn مرة اخرى يقوم بتحديد المشاعر في النص (sentiment analysis) على بعض التغريدات <a href="https://www.kaggle.com/mksaad/arabic-sentiment-twitter-corpus">من موقع تويتر</a>
</div>

<div dir="rtl">
تتوفر البيانات على شكل ملفيين احدهم يحتوى على التغريدات الإيجابية و الاخر على السلبية لذا سنقوم بتجميعهم و استخراج الخصائص منهم.
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># read the data
</span><span class="n">pos_reviews</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">"train_Arabic_tweets_positive_20190413.tsv"</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">'</span><span class="se">\t</span><span class="s">'</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="n">neg_reviews</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">"train_Arabic_tweets_negative_20190413.tsv"</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">'</span><span class="se">\t</span><span class="s">'</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">concat</span><span class="p">([</span><span class="n">pos_reviews</span><span class="p">,</span> <span class="n">neg_reviews</span><span class="p">])</span>
<span class="n">dataset</span><span class="p">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s">'sentiment'</span><span class="p">,</span> <span class="s">'text'</span><span class="p">]</span>
<span class="n">dataset</span><span class="p">.</span><span class="n">head</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/assets/images/intro-to-nlp-p1/sentiment-head.png" alt="data-head" class="align-center" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dataset</span><span class="p">[</span><span class="s">'sentiment'</span><span class="p">].</span><span class="n">value_counts</span><span class="p">()</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">pos</span>    <span class="mi">22761</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">neg</span>    <span class="mi">22514</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Name</span><span class="p">:</span> <span class="n">sentiment</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">int64</span>
</code></pre></div></div>

<div dir="rtl">
هنا نرى ان البيانات متوازنة بشكل كبير اذ ان عدد التغريدات الإيجابية قريب جدا من السلبية، والان سوف نقوم بتقسيم البيانات إلى جزء للتعلم و جزء للاختبار (train test split)
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="n">x_train</span><span class="p">,</span> <span class="n">x_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s">'text'</span><span class="p">],</span> <span class="n">dataset</span><span class="p">[</span><span class="s">'sentiment'</span><span class="p">],</span> <span class="n">test_size</span><span class="o">=</span><span class="p">.</span><span class="mi">2</span><span class="p">)</span>
<span class="n">x_train</span><span class="p">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">x_test</span><span class="p">.</span><span class="n">shape</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">((</span><span class="mi">36220</span><span class="p">,),</span> <span class="p">(</span><span class="mi">9055</span><span class="p">,))</span>
</code></pre></div></div>

<div dir="rtl">
والان يمكننا ان نقوم بتكوين قاعدة الكلمات و نرى جزء منها.
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vectorizer</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">(</span><span class="n">max_features</span><span class="o">=</span><span class="mi">1500</span><span class="p">)</span>
<span class="n">vectorizer</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_train</span><span class="p">)</span>
</code></pre></div></div>

<div dir="rtl">
هنا قمنا بتحديد عدد اقصى للخصائص التي يمكن تجميعها للحفاظ على الذاكرة و كذلك لتبسيط المثال ولكن في المتوسط تطبيقات اللغة تحتوى على كلمات اكثر بكثير.
</div>

<p><img src="/assets/images/intro-to-nlp-p1/ar-sentiment.png" alt="ar-sentiment" class="align-center" /></p>

<div dir="rtl">
يجب ان نقوم بتحويل النص إلى ارقام كما قمنا من قبل لنستطيع استخدام نموذج تعلم آلة (machine learning) على البيانات.
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x_train_v</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="p">.</span><span class="n">transform</span><span class="p">(</span><span class="n">x_train</span><span class="p">)</span>
<span class="n">x_test_v</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="p">.</span><span class="n">transform</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span>
</code></pre></div></div>

<div dir="rtl">
الآن يمكننا ان نقوم بتدريب نموذج بسيط مثل (Logistic Regression) و هو نموذج يستخدم في التحديد والاختيار (Classification).
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>

<span class="n">clf</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>
<span class="n">clf</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_train_v</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</code></pre></div></div>

<div dir="rtl">
والان يمكننا قياس جودة النموذج عن طريق مدى دقته على البيانات التي لم يراها من قبل
</div>

<div dir="rtl" class="notice--info">
(لاحظ ان هناك طرق اخرى لقياس مدى جودة النموذج مثل ال recall او التغطية و كذلك قياس ال f1-score وهي طريقة تجمع بين ال precision (الدقة في حالة الإختيار/ classification) و ال recall/التغطية )
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">clf</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">x_test_v</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mf">0.7168415240198786</span>
</code></pre></div></div>

<h3 class="text-right" id="عيوب-هذه-الطريقة">عيوب هذه الطريقة</h3>

<div dir="rtl">
يمكنك ان ترى ان قاعدة الكلمات تحتوي على كلمات كثيرة مثل (في، إلا، على، وهكذا) و هذه الكلمات تسمى كلمات وقف (stopwords) فهي لاتضيف كثيرا للمعنى وانما تستخدم لترتيب و تشكيل اللجملة فهذه الكلمات تأخذ مساحة كبيرة من الكلمات ولكنها ليست ذات اهمية كبيرة.
</div>

<div dir="rtl">
ايضا يمكننا ان نرى ان عدد الكلمات يمكن ان يزيد بشكل كبير جدا لان الوحدة الاساسية (token) بالاساس تستخرج على اساس المسافة و كما وضحنا سابقا فان هناك طرق افضل في استخراج الكلمات (tokenization) هذه الطرق تساهم بشكل كبير في تقليل المساحة المستخدمة.
</div>

<div dir="rtl">
ايضا من المشاكل التي يمكنك ملاحظتها هي ان الترتيب لا يعتد به على الإطلاق، اذ ان الجملتين الاتيتين لهما تقريبا نفس التمثيل.
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reviews</span> <span class="o">=</span> <span class="p">[</span> <span class="s">"انا احب هذا المنتج كثيرا لا يوجد لدي اي شكوى"</span><span class="p">,</span>
            <span class="s">"انا لا احب هذا المنتج على الإطلاق لدى مليون شكوى"</span><span class="p">]</span>
</code></pre></div></div>

<p><img src="/assets/images/intro-to-nlp-p1/bow-order-issue.png" alt="bow-order-issue" class="align-center" /></p>

<div dir="rtl">
فعلى الرغم من اختلافهم كليا الا ان هذه الطريقة لا تعتد بالترتيب لانه لايوجد ما يخبر البرنامج ان كلمة (احب) قد سبقها (لا)، لذا يجب ان نوجد حل لهذه المشكلة ايضا.
</div>

<div dir="rtl">
من عيوب هذه الطريقة ايضا انها لا تعطي اي مؤشر للكلمات المتشابهة، بمعنى ان كلمة (عشق) و كلمة (حب) لا يوجد اي دلالة على تشابهما بينما ان امكنا تحصيل معلومة كهذه فقد تفيدنا جدا.
</div>

<div dir="rtl">
ايضا ماذا إن ادخل المستخدم كلمة جديدة لم يراها النموذج اثناء التدريب، حينها سيتجاهلها النموذج بالكلية لانها لا تعتبر من الخصائص/القاموس الخاص بالنموذج.
</div>

<div dir="rtl">
يمكنك ان ترى ان هناك العديد من المشاكل ولكن لاتقلق هناك حلول لهذه المشاكل كما سنرى فيما يلي.
</div>

<h2 class="text-right" id="تمثيل-النص-من-خلال-معدلات-التكرار-و-الندرة-tf-idf">تمثيل النص من خلال معدلات التكرار و الندرة (TF-IDF)</h2>

<p><img src="http://3.bp.blogspot.com/-u928a3xbrsw/UukmRVX_JzI/AAAAAAAAAKE/wIhuNmdQb7E/s1600/td-idf-graphic.png" alt="tf-idf" class="align-center" /></p>
<center><a href="http://filotechnologia.blogspot.com/2014/01/a-simple-java-class-for-tfidf-scoring.html">المصدر</a></center>

<div dir="rtl">
هناك طريقة اخرى و هي تعديل بسيط على الطريقة السابقة لحل مشكلة الكلمات التي ليس لها اهمية كبيرة وهي عن طريق حساب معدل تكرارها في النص المستخدم و كذلك كل النصوص المتاحة، اذ ان الكلمة المستخدمة بكثرة في جميع النصوص فهي ليست مهمة بالضرورة مثل الكلمات الاقل ظهورا.
</div>

<div dir="rtl">
تقوم الطريقة بالاساس بتعيين قيمة لكل كلمة تعبر عن اهميتها و كلما زادت اهمية الكلمة كلما زادت القيمة.
</div>

\[W_x = tf_x \times \log(\frac{N}{df_x})\]

<div dir="rtl">
تقوم المعادلة بالأساس عن طريق حساب معدل تكرار الكلمة في النص الحالي (term frequency - tf) و كذلك حساب عدد النصوص التي ظهرت بها هذه الكلمة (document frequency - df) دعنا نستعرض مثال لكلمة مستخدمة كثيرا مثل حرف الجر (في) سوف نجد انها تقريبا سوف تظهر في كل النصوص وبهذا سوف تكون قيمة ال (df) كبيرة و قريبة جدا من (N) و هو عدد النصوص المتاحة اذا ستكون محصلة العملية log(N/df) قريبة من 0 لان كلما زادت قيمة df كلما نقصت قيمة الكسر و بالتبعية قيمة اللوغاريتم على عكس لو نقصت قيمة ال df كلما زادت قيمة الكسر و كذلك تزداد قيمة اللوغاريتم، الذي يرمز له غالبا بالقيمة (inverse document frequency - idf).
</div>

<div dir="rtl">
هنا يمكن ان نرى مثال على استخدام tfidf على جزء من البيانات
</div>

<p><img src="/assets/images/intro-to-nlp-p1/tfidf-vectorizer.png" alt="tfidf-vectorizer" class="align-center" /></p>

<div dir="rtl">
كما ترى فإن لكل كلمة قيمة ناتجة من حساب معدل التكرار وليس مجرد عددها كما كان في السابق.
</div>

<div dir="rtl">
يمكننا تغير سطر واحد فقط في البرنامج السابق لاستخدام معدل التكرار (tf-idf) بدلا من العدد فقط (count vectorizer).
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="kn">import</span> <span class="n">TfidfVectorizer</span>

<span class="n">vectorizer</span> <span class="o">=</span> <span class="n">TfidfVectorizer</span><span class="p">()</span>
<span class="n">vectorizer</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_train</span><span class="p">)</span>
</code></pre></div></div>

<div dir="rtl">
سوف نلاحظ زيادة طفيفة في جودة توقعاتنا ولكن سوف تظل مشاكل اخرى قائمة مثل ان (لا احب) يتم قراءتها على انها (لا) و (احب) و في هذا الإطار نرى ان كلمة احب بالتأكيد تدل على رأي إيجابي لذلك غالبا سوف يتوقع نموذجنا ان النص ايجابي، وسوف نقوم باستعراض طريقة يمكنها حل هذه المشكلة بنسبة جيدة.
</div>

<h2 class="text-right" id="تمثيل-النص-باستخدام-مجموعة-كلمات-n-gram">تمثيل النص باستخدام مجموعة كلمات (N-gram)</h2>

<p><img src="https://vitalflux.com/wp-content/uploads/2018/02/Ngram-language-model-explained-with-examples.png" alt="ngram" class="align-center" /></p>
<center><a href="https://vitalflux.com/n-gram-language-models-explained-examples/">المصدر</a></center>

<div dir="rtl">
لمعالجة مشكلة مثل (لا احب) وايضا الكلمات المركبة بشكل عام مثل (أبو بكر) وايضا (حسبي الله ونعم الوكيل) على سبيل المثال نحتاج لان ننظر ليس فقط لكلمة واحدة وانما ننظر إلى عدة كلمات متتالية مرة واحدة، وهذه هي طريقة ال (ngrams) التي تعتمد على وجود نافذة بحجم معين (مثلا كلمتين) ونختار كل كلمتين متتاليتين ليصبحوا وحدة نصية (token)، اذا كانت النافذة ذات حجم 3 يصبح مسماهم (trigrams) و هكذا.
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">text</span> <span class="o">=</span><span class="p">[</span>
    <span class="s">"مرحبا"</span><span class="p">,</span>
    <span class="s">"اهلا يا صديقي"</span><span class="p">,</span>
    <span class="s">"كيف حالك يا صديقي"</span><span class="p">,</span>
    <span class="s">"مرحبا صديقي"</span>
<span class="p">]</span>

<span class="c1"># bigram example
</span><span class="n">vectorizer</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">(</span><span class="n">ngram_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">vectorizer</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/intro-to-nlp-p1/bigrams.png" alt="bigrams" class="align-center" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">text</span> <span class="o">=</span><span class="p">[</span>
    <span class="s">"مرحبا"</span><span class="p">,</span>
    <span class="s">"اهلا يا صديقي"</span><span class="p">,</span>
    <span class="s">"كيف حالك يا صديقي"</span><span class="p">,</span>
    <span class="s">"مرحبا صديقي"</span>
<span class="p">]</span>

<span class="c1"># trigram example
</span><span class="n">vectorizer</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">(</span><span class="n">ngram_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">vectorizer</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/intro-to-nlp-p1/trigrams.png" alt="trigrams" class="align-center" /></p>

<div dir="rtl">
استخدام مجموعات الكلمات (ngram) سوف يحسن اداء النموذج الخاص بك لانه يوفر للنموذج نافذة اكبر يستطيع النظر من خلالها للنص ولكنه يزيد من عدد الخصائص بشكل كبير كما ترى و ايضا مازالت هناك بعض المشاكل التي لم نقم بحلها بعد مثل الترتيب وكذلك مدى تشابه الكلمات ذات المعاني المتقاربة.
</div>

<h2 class="text-right" id="تمثيل-النص-باستخدام-متجهات-المعاني-word-embeddings">تمثيل النص باستخدام متجهات المعاني (word embeddings)</h2>

<div dir="rtl">
حتى الآن كان تمثيلنا للنص مقتصر على شكل مجموعة ارقام تمثل النص ككل، ولكن الآن نريد عمل تمثيل للكلمة الواحدة في شكل متجه (vector) والذي سوف يكون مفيد في استخدامات كثيرة خاصة في مجالات التعلم العميق (deep learning) فدعنا نرى بعض اشهر الطرق في تمثيل النص على شكل متجه.
</div>

<h3 class="text-right" id="الترميز-التقليدي-للكلمة-الواحدة-one-hot-encoding">الترميز التقليدي للكلمة الواحدة (one hot encoding)</h3>

<div dir="rtl">
في هذه الطريقة سوف نقوم بتحديد رقم لكل كلمة من الكلمات المميزة التي لدينا ثم نقوم بتمثيل كل كلمة على شكل متجه طوله عدد الكلمات المميزة لدينا و قيمته صفر في جميع الاماكن ماعدا إحداثي الكلمة، يمكنك ان ترى بشكل اوضح في المثال الآتي.
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="n">text</span> <span class="o">=</span> <span class="s">"مرحبا هلا يا صديقي كيف حالك يا صديقي مرحبا صديقي"</span>

<span class="n">text2idx</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">text</span><span class="p">.</span><span class="n">split</span><span class="p">()),</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">text2idx</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

<span class="n">text2idx</span><span class="p">[</span><span class="s">'مرحبا'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">5</span>
</code></pre></div></div>

<div dir="rtl">
هنا قمنا ببناء المتغير <code>text2idx</code> حيث يحتوي على كل كلمة والرقم المقابل لها و استخدمنا هنا <code>defaultdict</code> حتى نحصل على قيمة 0 عندما نستخدمه مع كلمات جديدة، الآن دعنا نستخدم ما قمنا بعمله لتكوين المتجه المعبر عن الكلمة.
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">word</span> <span class="o">=</span> <span class="s">'مرحبا'</span>

<span class="n">word_vector</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">text2idx</span><span class="p">.</span><span class="n">keys</span><span class="p">())))</span>
<span class="n">word_vector</span><span class="p">[</span><span class="n">text2idx</span><span class="p">[</span><span class="n">word</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">word_vector</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
</code></pre></div></div>

<div dir="rtl">
كما ترى هنا قمنا بعمل متجه فارغ بحجم مجموع الكلمات التي لدينا و من ثم قمنا بتغير قيمة احداثي هذه الكلمة فقط ليصبح قيمته 1 و اذا استخدمناه مع كلمة جديدة سوف نحصل على تمثيل مثل ما يلي.
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">word</span> <span class="o">=</span> <span class="s">'مصر'</span>

<span class="n">word_vector</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">text2idx</span><span class="p">.</span><span class="n">keys</span><span class="p">())))</span>
<span class="n">word_vector</span><span class="p">[</span><span class="n">text2idx</span><span class="p">[</span><span class="n">word</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">word_vector</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
</code></pre></div></div>

<div dir="rtl">
الكلمات التي لم نراها من قبل والتي لم تكن متواجدة في البيانات التي تمرنا عليها سوف تحصل على متجه يحتوي على 1 في الخانة الاولى التي خصصناها للكلمات الخارجة عن القاموس الخاص بنا (Out of Vocab).
</div>

<div dir="rtl">
تمثيل النصوص بهذه الطريقة مهم للغاية حيث انه يتم استخدامه في الطرق الحديثة كما سنرى لاحقا. ولكن كما ترى فهو لا يحتوي على اي معلومة عن الكلمة ماعدا رقم الكلمة في قاموس كلماتنا و هذه ليست معلومة يمكننا من خلالها استخراج معاني مفيدة عن التشابه بين الكلمات و معانيها.
</div>

<h3 class="text-right" id="متجهات-الكلمات-ذات-المعنى-word2vec">متجهات الكلمات ذات المعنى (word2vec)</h3>

<div dir="rtl">
تخيل ان تقوم بعمل عملية حسابية على الكلمات كالمثال الآتي.
</div>

<p class="text-center">القاهرة - مصر + فرنسا ~= باريس</p>

<div dir="rtl">
في هذه المعادلة نقوم باستخراج باريس بناءا على العلاقة بين مصر و القاهرة اذ ما تقوله المعادلة هو العلاقة بين القاهرة و مصر كالعلاقة بين فرنسا و ماذا ؟ بالطبع يمكنك ان تتخيل ان الإجابة باريس عاصمة فرنسا، ولكن كيف يمكننا تطبيق هذه المعادلة بالفعل اذ يقوم البرنامج بالإجابة عوضا عنا بباريس؟
</div>

<div dir="rtl">
في <a href="https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf">ورقتهم العلمية</a> توماس ميكولوف وزملائه قامو بإقتراح نموذج صياغة للكلمات على شكل متجه بحيث يحتوي المتجه على معلومات عن الكلمة، والكلمات التي تظهر مع نفس المحيط من الكلمات سوف تحصل على متجهات متشابهة، لن نتطرق لتفاصيل عمل النموذج في الوقت الحالي لكن يمكنك الإطلاع عليه من خلال <a href="http://jalammar.github.io/illustrated-word2vec/"> هذا المقال</a> الرائع لكن دعنا نرى كيفية استخدام هذا النموذج و كيف يمكنه ان يفيدنا في عملية معالجة النصوص من خلال مكتبة <a href="https://spacy.io/">spaCy</a>.
</div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$pip</span> <span class="nb">install </span>spacy
<span class="nv">$python</span> <span class="nt">-m</span> spacy download en_core_web_md
</code></pre></div></div>

<div dir="rtl">
الآن قمنا بتحميل المكتبة والملفات التي نحتاجها لتوليد متجهات الكلمات، لنرى كيف يمكننا استخدامها.
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">spacy</span>
<span class="n">nlp</span> <span class="o">=</span> <span class="n">spacy</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">"en_core_web_md"</span><span class="p">)</span>

<span class="n">cat</span> <span class="o">=</span> <span class="n">nlp</span><span class="p">(</span><span class="s">"cat"</span><span class="p">)</span>
<span class="n">cat</span><span class="p">.</span><span class="n">vector</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.15067</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.024468</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.23368</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.23378</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.18382</span> <span class="p">,</span>  <span class="mf">0.32711</span> <span class="p">,</span>
<span class="o">&gt;&gt;&gt;</span>       <span class="o">-</span><span class="mf">0.22084</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.28777</span> <span class="p">,</span>  <span class="mf">0.12759</span> <span class="p">,</span>  <span class="mf">1.1656</span>  <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">)</span>
</code></pre></div></div>

<div dir="rtl">
حصلنا الآن على المتجه الخاص بكلمة قطة، المتجه يحتوي على 300 رقم ولكن استعرضنا فقط اول 10 منهم، الآن دعنا نحصل على متجهيين اخريين.
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dog</span> <span class="o">=</span> <span class="n">nlp</span><span class="p">(</span><span class="s">"dog"</span><span class="p">)</span>
<span class="n">car</span> <span class="o">=</span> <span class="n">nlp</span><span class="p">(</span><span class="s">"car"</span><span class="p">)</span>
</code></pre></div></div>

<div dir="rtl">
لاحظ الآن كيف يمكننا مقارنة الكلمات.
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cat</span><span class="p">.</span><span class="n">similarity</span><span class="p">(</span><span class="n">car</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mf">0.3190752856973872</span>

<span class="n">cat</span><span class="p">.</span><span class="n">similarity</span><span class="p">(</span><span class="n">dog</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mf">0.8016854705531046</span>
</code></pre></div></div>

<div dir="rtl">
كما ترى على الرغم من تشابه كلمة (cat) و (car) من حيث الأحرف، إلا ان التشابه بينهم ضعيف جدا مقارنة بالتشابه بين (cat) و (dog) هذا لان المعنى اقرب بالطبع، فكما ترى ان متجهات الكلمات تتضمن المعاني بداخلها و بالطبع المعاني المتضمنة داخل المتجهات تأتي بعد تدريب معين لن يسعنى تغطيته في الوقت الحالي لكن يمكنك الإطلاع على الورقة البحثية التي اشرنا إليها.
</div>

<div dir="rtl" class="notice--info">
تتم حساب نسبة التشابه بين المتجهات على اساس جيب الزاوية (cosine) بينهم، يمكنك الإطلاع على طريقة حسابها من <a href="https://deepai.org/machine-learning-glossary-and-terms/cosine-similarity">هنا</a>
</div>

<div dir="rtl" class="notice--info">
لاحظ ان مكتبة <code>spaCy</code> تستخدم نموذج مختلف قليلا عن الذي اشرنا إليه في الورقة البحثية لكنه يقوم بنفس الوظيفة بشكل افضل قليلا، يمكنك الإطلاع عليه من خلال الورقة البحثية الخاصة به من <a href="https://nlp.stanford.edu/pubs/glove.pdf">هذا الرابط</a>
</div>

<h3 class="text-right" id="استخدام-المتجهات-في-تطبيق-تحديد-العاطفة-في-النص">استخدام المتجهات في تطبيق تحديد العاطفة في النص</h3>

<div dir="rtl">
لنقوم باستخدام المتجهات مع نماذجنا يجب علينا ان نعيد تمثيل النص على هيئة متجهات، ولكن نحن نحصل على متجه لكل كلمة فكيف نحصل على متجه للنص الكامل ؟
</div>

<div dir="rtl">
احد اشهر الطرق هي ان نقوم باستخدام مجموع المتجهات الخاصة بكل كلمة لتصبح المتجه الممثل للنص بكامله، هناك طرق اخرى سوف نتحدث عناه لاحقا ولكن الآن سوف نستخدم هذه الطريقة.
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">text</span> <span class="o">=</span> <span class="s">"this is a simple text"</span>
<span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">300</span><span class="p">,))</span>

<span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">nlp</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="n">vector</span> <span class="o">+=</span> <span class="n">word</span><span class="p">.</span><span class="n">vector</span>

<span class="n">vector</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.46234499</span><span class="p">,</span>  <span class="mf">0.81979895</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.83246968</span><span class="p">,</span>  <span class="mf">1.26062</span>   <span class="p">,</span>  <span class="mf">0.389594</span>  <span class="p">,</span>
<span class="o">&gt;&gt;&gt;</span>        <span class="o">-</span><span class="mf">0.428568</span>  <span class="p">,</span>  <span class="mf">0.24449199</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.57974999</span><span class="p">,</span>  <span class="mf">0.15832401</span><span class="p">,</span>  <span class="mf">9.83159995</span><span class="p">])</span>
</code></pre></div></div>

<div dir="rtl">
يمكنك ان تلاحظ هنا ان كل كلمة سوف يتم تمثيلها بمتجه يعبر عنها، ولان المتجهات الموجودة بالفعل في النموذج كثيرة وقد تكون اكثر من الكلمات التي تتدرب عليها في البرنامج الخاص بك، اذا قام المستخدم بإدخال كلمة جديدة لم يراها النموذج الخاص بك اثناء التدريب ولكن لها متجه معرف بالفعل فان النموذج الخاص بك سوف يحصل على متجه شبيه بالمتجهات التي حصل عليها اثناء تدريبه لان متجه هذه الكلمة لن يكون جديد كليا، دعنا نستعرض مثال على هذه الحالة تحديا.
</div>

<div dir="rtl">
دعنا نقول ان اثناء التدريب نوذجك تعرض لكلمة يحب ولكنه لم يتعرض لكلمة يعشق، وعند استخدام النوذج الخاص بك ادخل المستخدم كلمة يعشق، في الحالة العادية سوف يقوم النموذج بتجاهلها ولكن في هذه الحالة (لو كان لها متجه معرف في نموذج المتجهات الذي هو مختلف عن نموذجك الخاص) حين إذ سوف تحصل منها على متجه يشبه كثيرا المتجه الخاص بكلمة (يحب) وهكذا يمكن للنموذج الخاص بك ان يفهم انها ليست كلمة جديدة كليا وانما كملة شبيهة بكلمة تعرض لها مسبقا.
</div>

<h3 class="text-right" id="بعض-الملاحظات-على-تمثيل-النص-بشكل-متجهات-الكلمات-word2vecglove">بعض الملاحظات على تمثيل النص بشكل متجهات الكلمات (word2vec/glove)</h3>

<div dir="rtl">
لاحظ هنا ان جودة تلك المتجهات تتوقف على جودة النموذج الذي استخدم في تكوينهم، اذ انه اذا كان ضعيفا ولم يتم توفير بيانات كافيه له فلن تحصل على متجهات فعالة وجيدة و انما متجهات غير معبرة لان في اغلب الاحيان لن يرى الكلمة اكثر من مرة في اكثر من موضع حتى يفهم المحتوى الذي تظهر به ليجد شبيهاتها من الكلمات.
</div>

<div dir="rtl">
لاحظ ايضا كيف ان المتجه الخاص بالكلمة لا يختلف بإختلاف مكان استخدامها، على سبيل المثال (صليت المغرب في المغرب) كما تلاحظ هنا ان (المغرب) الاولى تعني صلاة المغرب اما الثانية فتعني البلد، في حالة استخدامنا لنموذج مبنى بطريقة (word2vec) او طريقة (GloVe) -وهما الطريقتان المستخدمان في المتجهات التي قمنا بعرضها- سوف تحصل على نفس المتجه وهذا بالتأكيد ليس الحل الأمثل.
</div>

<div dir="rtl">
ايضا جمع المتجهات مكننا من تحصيل المعلومات الكامنة في النص بإكمله ولكن بالتأكيد لايغني عن حاجتنا لان نأخذ في اعتبارنا ترتيب النص، لان حتى بعد ان نقوم بجمع المتجهات، لن تختلف النتيجة بإختلاف ترتيب النص فمازلنا في حاجة إلى حل تلك المشكلة.
</div>

<h2 class="text-right" id="الاستنتاج">الاستنتاج</h2>

<div dir="rtl">
حتى الآن قمنا بتغطية العديد من الطرق لتمثيل النص وكيفية استخدامهم بلغة البايثون لعمل تطبيق بسيط للغاية، واستعرضنا اهم العقبات والمشاكل التي تواجه هذه الطرق و هكذا كيف ان هناك طرق اخرى لحل هذه المشاكل وهذا نهاية النصف الاول من هذه المقدمة المختصرة البسيطة عن معالجة الآلة باستخدام خوارزميات تعليم الآلة.
</div>

<div dir="rtl">
في الجزء القادم سوف نتحدث عن نماذج اخرى افضل في معالجة النصوص و كيفية معالجتها للمشاكل التي تعرضنا لها حتى الآن وايضا سنتحدث عن النماذج المستخدمة حاليا في التقنيات الحديثة التي نراها في تطبيقاتنا بشكل يومي.
</div>

<div dir="rtl" class="notice--success">
في هذا المقال حاولت تبسيط بعض المصطلحات للغتنا العربية من اجل تسهيل عملية الشرح ولتبسيط المعلومة، في حالة اي خطأ املائي او اقتراح افضل للترجمة فأنا ارحب جدا بذلك يمكنك التعليق على المقال او مراسلتي لتعديل و تحسين المحتوى، ووفقنا الله وإياكم لما يحب ويرضى.
</div>

<h2 class="text-right" id="مصادر">مصادر</h2>

<div dir="rtl">
<ul>
<li><a href="https://www.coursera.org/learn/language-processing">كورس معالجة اللغة من جامعة HSE</a></li>
<li><a href="https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf">الورقة البحثية الخاصة بنموذج word2vec</a></li>
<li><a href="http://jalammar.github.io/illustrated-word2vec/">شرح توضيحي رائع لطريقة عمل word2vec</a></li>
<li><a href="https://nlp.stanford.edu/pubs/glove.pdf">الورقة البحثية الخاصة بنموذج glove</a></li>
</ul>
</div>]]></content><author><name>Ali Abdelaal</name></author><category term="Blog" /><category term="arabic" /><category term="natural language processing" /><category term="machine learning" /><summary type="html"><![CDATA[نظرة عامة في مجال معالجة اللغة باستخدام خوارزميات تعلم الآلة]]></summary></entry><entry><title type="html">النزول التدريجي و بعض مشتقاته و استخدامهم في علم الآلة</title><link href="/blog/gradient-descent-family/" rel="alternate" type="text/html" title="النزول التدريجي و بعض مشتقاته و استخدامهم في علم الآلة" /><published>2020-05-16T00:00:00+00:00</published><updated>2020-05-16T00:00:00+00:00</updated><id>/blog/gradient-descent-family</id><content type="html" xml:base="/blog/gradient-descent-family/"><![CDATA[<script src="https://formspree.io/js/formbutton-v1.min.js" defer=""></script>

<script>
   window.formbutton=window.formbutton||function(){(formbutton.q=formbutton.q||[]).push(arguments)};
   formbutton("create", {
     title: "Hello there 👋",
     description: "Subscribe for my new content, or drop a message 🥳",
     action: "https://formspree.io/xbjzaerk",
     theme: "classic",
     fields: [{
      name: "name",
      type: "text",
      label: "Your Name",
      required: true,
      placeholder: "Say your name 🤔"
    },
    {
      name: "email",
      type: "email",
      label: "Your Email",
      placeholder: "Enter your em@il 📬",
      required: true
    },
    {
      name: "Message",
      type: "textarea",
      placeholder: "drop a message ! 🤓 if you want to 🤷‍♂️"
    },
    {
      type: "submit"
    }],
     })
</script>

<h2 class="text-right" id="مقدمة">مقدمة</h2>

<div dir="rtl">
في هذا المقال سنتحدث عن خوارزمية النزول التدريجي او (Gradient Descent) وهي تعد اشهر الطرق و اكثرها استخداما في حل المعادلات المستخدمة في خوارزميات تعلم الآلة (machine learning) و كذلك التعلم العميق (deep learning).
<br />
سوف نتعرض لكيفية عمل النزول التدريجي و اهميته و المشاكل التي نتعرض لها مع استخدامه و كيف ان هناك بعض التحديثات عليه التي تمكننا من ان نتفادى هذه المشاكل و ان نحصل على نتائج افضل.
</div>

<p><img src="https://www.charlesbordet.com/assets/images/gradient-descent/gradientdescent-alpha0.05.gif" alt="grad-desc" class="align-center" /></p>
<center><a href="https://www.charlesbordet.com/en/gradient-descent/">المصدر</a></center>

<h2 class="text-right" id="ما-هو-النزول-التدريجي">ما هو النزول التدريجي</h2>

<div dir="rtl">
كما تحدثنا من قبل في مقالنا السابق عن كيفية تعلم الآلة والذي يمكنك الإطلاع عليه من <a href="https://aliabdelaal.github.io/blog/intro-to-ml/">هنا</a>، ان وظيفة النزول التدريجي هو تقليل معدل الخطأ في توقعاتنا و التي هي ناتجة بالاساس من استخدام بعض الأوزان.
<br />
يمكنك تخيل المشكلة كأنك على سطح جبل ما ولا ترى حولك بسبب الضباب و لكنك تريد النزول، حينئذا ستتحسس طريقك و تبحث عن اتجاه الانخفاض وتبدأ في التحرك من خلاله، هذا ما يفعله بالضبط النزول التدريجي، اذ انه يبحث ايضا في كل اتجاه (بالنسبة لنا هنا كل اتجاه يمثل وزن من الاوزان) اين يجب ان تكون خطوته القادمة؟ يمين؟ يسار؟ امام ؟ ام خلف ؟.
</div>

<p><img src="/assets/images/gradient-descent-family/image-1.png" alt="mountain-descent" class="align-center" /></p>
<center><a href="https://unsplash.com/photos/Ho2s540bWiI">المصدر</a></center>

<h2 class="text-right" id="نظرة-داخل-النزول-التدريجي">نظرة داخل النزول التدريجي</h2>

<div dir="rtl">
دعنا ننظر عن كثب كيف يعمل هذا النزول التدريجي

$$w_t = w_{t-1} - \eta \frac{\partial }{\partial w}E(w)$$

كما تتذكر من المقال السابق هذه كانت معادلة النزول التدريجي و هي بإختصار اننا سوف نرى ما معدل الخطأ الذي قمنا به ثم نرى كيف يمكننا ان نحسن هذا الخطأ عن طريق حساب معدل التغير (التفاضل) ثم نقوم بتغيير الوزن القديم بما هو قيمته سالب التفاضل (لان التفاضل يشير لإتجاه الزيادة) بمعامل η والذي يعبر عن معدل التعلم او (learning rate) دعنا نرى هذه المعادلة بالرسم لنستوضح اكثر
</div>

<p><img src="https://blog.paperspace.com/content/images/2018/05/68747470733a2f2f707669676965722e6769746875622e696f2f6d656469612f696d672f70617274312f6772616469656e745f64657363656e742e676966.gif" alt="descent-3d" class="align-center" /></p>
<center><a href="https://blog.paperspace.com/intro-to-optimization-in-deep-learning-gradient-descent/">المصدر</a></center>

<div dir="rtl">
الرسم بالأعلى يظهر كيف يقوم النزول التدريجي بإيجاد اقل نقطة في الدالة و التي لونها ازرق هنا، ولكن يمكن ايضا ان ترى اشكال توضيحية للنزول التدريجي في شكل ما يسمى (contours) وهي تعبر عن الشكل الذي رأيناه باﻷعلى ولكن اذا قمنا بقطع شريحة افقية به او نظرنا إليه من أعلى و سيصبح شكله كما يلي.
</div>

<p><img src="https://i2.wp.com/www.adeveloperdiary.com/wp-content/uploads/2018/11/How-to-visualize-Gradient-Descent-using-Contour-plot-in-Python-adeveloperdiary.com-1.jpg?w=800" alt="3d-and-contour" class="align-center" /></p>
<center><a href="http://www.adeveloperdiary.com/data-science/how-to-visualize-gradient-descent-using-contour-plot-in-python">المصدر</a></center>

<div dir="rtl">
هنا يتضح لنا كيف ان الرسم الثنائي الابعاد (contour) ماهو الا شريحة من الرسم الثلاثي الأبعاد لذا ان رأيت رسم بهذا الشكل فلا تقلق انها تعبر عن نفس الشئ.
</div>

<h2 class="text-right" id="النزول-التدريجي-العشوائي-stochastic-gradient-descent">النزول التدريجي العشوائي (Stochastic Gradient Descent)</h2>

<div dir="rtl">
النزول التدريجي يحتاج إلى حساب معدل التغيير كما رأينا من قبل، وفي الاعدادات العادية يتم حساب الخطأ بناءا على كل ما توقعناه كما رأينا مسبقا وهذا يعطينا نظرة شاملة عن الخطأ في جميع البيانات التي لدينا ولكن عندما يصبح حجم هذه البيانات كبير جدا يصبح الوضع بطئ للغاية لانه عند كل عملية تحديث للوزن سوف نضطر إلى حساب الخطأ في جميع البيانات المتاحة و بالتالي تصبح عملية التعلم بشكل عام ابطئ بكثير، لذلك يوجد اقتراح افضل و هو ان تقوم بأخذ الخطأ من مثال واحد من البيانات و نرى اين يمكننا ان نتحرك، بالطبع سيخطر ببالك ان ربما يكون هذا التحرك في اتجاه خاطئ لان هذا المثال الذي قمنا بإختياره ليس ممثل للبيانات كلها و هذا صحيح ويتسبب في ان تكون عملية النزول عشوائية قليلا ولكن في المجمل هي عملية نزول مازالت، ولكن في المقابل تصبح عملية النزول اسرع بكثير.
</div>

<p><img src="/assets/images/gradient-descent-family/batch-gd.gif" alt="batch-gd" class="align-center" /></p>

<div dir="rtl">
هنا نرى كيف يقوم النزول التدريجي بالنزول تدريجيا بخطوات ثابتة نحو الهدف و هو اقل قيمة في الدالة كما نراها تعالى نرى على الناحية الاخرى النزول التدريجي العشوائي.
</div>

<p><img src="/assets/images/gradient-descent-family/batch-sgd.gif" alt="stochastic-gd" class="align-center" /></p>

<div dir="rtl">
يمكنك ملاحظة عدة اشياء هنا، مثل ان الخطوات التي يتبعها النزول ليست بالضرورة كلها صحيحة فهو يحيد في بعض الخطوات و ايضا عندما يقترب من النقطة المطلوبة يبدأ في التقلب بعيدا عن الهدف ولا يصل إلى الهدف مرة واحدة وهذا من عيوب هذه الطريقة.
</div>

<h2 class="text-right" id="النزول-التدريجي-المجزء-mini-batch-gradient-descent">النزول التدريجي المجزء (Mini-Batch Gradient Descent)</h2>

<div dir="rtl">
هنا الفكرة الرئيسية هي ان تقوم بعمل خطوات تدريجية ايضا بنفس المبدأ السابق العشوائي ولكن بدل من ان نقوم بالتحرك على اساس خطوة واحدة سوف نختار عدد معين من العينات و نأخذ الخطأ بناءا عليهم ثم نقوم بتحديث الأخطاء و هكذا نتغلب على مشكلة العشوائية الناجمة عن اختاير نقطة واحدة ولكن بالطبع سيظل هناك جزء من الخطأ عن الطريقة التقليدية ولكن هذه الطريقة تساعد كما وضحنا في سرعة العملية و كذلك الاتجاه الذي يسير فيه الاوزان.
</div>

<p><img src="/assets/images/gradient-descent-family/mini-batch-gd.gif" alt="mini-batch-gd" class="align-center" /></p>

<div dir="rtl">
يمكنك ان ترى هنا بعض العشوائية في المنتصف ولكنها اقل بكثير من النموذج حيث تم التحديث بناءا على عينة واحدة فهنا نقوم بعمل الخطوة بناءا على 5 عينات فقط وطبعا كلما زاد هذا العدد كلما كانت خطواتنا ادق.
</div>

<h2 class="text-right" id="قيمة-التفاضل-قد-تخدعك-في-بعض-الأحيان">قيمة التفاضل قد تخدعك في بعض الأحيان</h2>

<p><img src="http://dataplusplus.ca/blog/content/1-2017/20171002-gradient-descent-with-momentum/gd.png" alt="oscillation" class="align-center" /></p>
<center><a href="http://dataplusplus.ca/blog/2017/gradient-descent-with-momentum">المصدر</a></center>

<div rtl="rtl">
احيانا يكون التوجه العام للنزول لدينا صحيح ولكن عند بعض النقاط نجد ان التفاضل يدفعنا لأماكن مختلفة عن كل التفاضلات السابقة، ففي هذه الحالة نريد ان نقوم بتقييم النزول وعندما نجد ان هناك خطوة غير منطقية لا نتبعها بشكل مباشر و انما ندع الأمر للنقاط السابقة ايضا حتى تحدد هل هذا الاتجاه صحيح بشكل كلي ام يجب الا نذهب في هذا الأتجاه.
</div>

<p><img src="https://davidmatablog.files.wordpress.com/2017/08/localminima.png?w=1000" alt="local-minimal" class="align-center" /></p>
<center><a href="https://davidmatablog.wordpress.com/2017/10/26/stochastic-gradient-descent-python/">المصدر</a></center>

<div dir="rtl">
ايضا في بعض المناطق في دالتنا قد تجد اماكن تسمى الصغرى المحلية (local minimum) و ايضا الصغرى العظمى (global minimum) وقد نظن اثناء النزول ان النقاط الصغرى المحلية هي اصغر نقطة لان التفاضل سيبقينا في النقطة المحلية، ولكن نحن نحتاج إلى طريقة تمكننا من الهروب من هذه النقطة المحلية و النزول في الصغرى العظمى، فيما يلي سوف نستعرض طرق لحل هذه المشكلة.
</div>

<h2 class="text-right" id="استخدام-قوة-الدفع-momentum">استخدام قوة الدفع (Momentum)</h2>

<p><img src="https://miro.medium.com/max/640/0*d3qXU_U2gCUVgQ6F" alt="local-minimal" class="align-center" /></p>
<center><a href="https://medium.com/@kaitotally/adam-the-birthchild-of-adagrad-and-rmsprop-b5308b24b9cd?source=rss------artificial_intelligence-5">المصدر</a></center>

<div dir="rtl">
تقوم هذه الطريقة على مبدأ قوة الدفع كأنك تلقي بكرة من فوق تلة، اثناء انزلاقها سوف تحصل على قوة دفع تزداد مع الوقت وسوف تصبح مع الوقت سريعة بحيث لا يمكن ان تقف في حفرة صغيرة في طريقها و انما ستتوقف فقط عند نهاية هذه التلة، هذه بالضبط هي نظرية عمل قوة الدفع في النزول التدريجي ايضا ولكن هنا الكرة هي قيمة الأوزان و التلة هي الخطأ و سوف نستخدم الخطوات السابقة حتى تصبح داعما لنا و كذلك تزيد من الدفع للأوزان نحو النقطة الصغرى العظمى.
</div>

<div dir="rtl">
دعنا نسترجع معادلة النزول التدريجي التي ذكرناها و نرى كيف يمكننا تعديلها لتتضمن مبدأ الدفع هذا

$$ w_t = w_{t-1} - \eta \frac{\partial}{\partial w}Error(w)$$ 

سنقوم الآن بتعريف المعادلة الجديدة التي سوف نستخدمها

$$ w_t = w_{t-1} - h_t $$

إذا التحديث الذي يحدث على الاوزان الآن اصبح متغير، دعنا نرى اذا ماهو المتغير الجديد h

$$ h_t = \alpha h_{t-1} + \eta g_t $$

$$ g_t = \frac{\partial}{\partial w}Error(w) $$

هنا يمكنك ان ترى اننا اختصرنا التفاضل لرمز g لتسهيل العملية و الآن دعنا نتحدث عن هذه الرموز الجديدة.
<br />
هنا الرمز α هو متغير تقوم بتحديده مسبقا و هو في المعادلة هنا يعبر عن اهمية ht-1 في المعادلة و غالبا ما تكون قيمته 0.9 اذا التحديث الجديد للأوزان مازال كما هو فيما يخص الجزء الثاني من المعادلة و انما هناك جزء جديد تم اضافته و هو محصلة h فإن المعادلة ببساطة تقوم بجمع قيمة h على مدار مرات التعلم (iterations) و بالتالي عند كل خطوة سيكون اتجاهك متوقف على التفاضل و لكن ايضا متوقف على كل الخطوات السابقة فان معادلة h يمكنك ان تفكر فيها على هذا النحو مثلا عند الخطوة الثانية

$$ h_2 = 0.9( 0.9( 0.9*0 + \eta g_0 ) + \eta g_1 ) + \eta g_2$$

كما ترى هنا هي ببساطة تراكم كل ما سبق من خطوات مع اضافة المعامل α والذي يمكنك ان تفكر فيه على انه معامل الاحتكاك اثناء النزول لان كلما قل هذا المعامل صار الاعتماد على التفاضل الحالي فقط اي لا قوة دفع و كلما زاد المعامل واقترب من 1 صار الاحتكاك اقل ما يمكن وخطوتك ستزداد بمقدار h والذي يحمل كل الخطوات السابقة.
<br />
لاحظ هنا ايضا انه اذا في مرحلة ما كان التفاضل بقيمة مخالفة لكل ما سبق على سبيل المثال تفاضل قيمته سالبة على عكس ما سبقه كلهم، حينئذ يعادل طرفي المعادلة بعضهم لان العزم بالفعل له تأثير قوي على خطوتنا و ان كانت الخطوة مخالفة للعزم فغالبا سوف تقل قيمتها وقد تتم تجاهلها، يشبه الامر ان تكون الكرة منزلقة من قمة المنحدر و قام احد بدفعها للاعلى ربما ترتفع قليلا ولكن لن تغير اتجاهها بسب الدفع الحاصل عليها بالفعل و ايضا بنفس المبدأ اذا سقطت في حفرة صغرى محلية سوف تهرب منها بسهولة و تكمل نزولها نحو الصغرى العظمى.
</div>

<h2 class="text-right" id="تفاضل-نستروف-المتسارع-nag">تفاضل نستروف المتسارع (NAG)</h2>

<p><img src="/assets/images/gradient-descent-family/nag.png" alt="mini-batch-gd" class="align-center" /></p>
<center><a href="https://g.co/kgs/EQnEFT">المصدر</a></center>

<div dir="rtl">
قام يوري نستروف بعمل تعديل بسيط في طريقة التدافع تمكننا من تسريع العملية وكذلك الحصول على نتائج افضل، و الطريقة ببساطة هي ان نسمح للنقطة بالتحرك في اتجاه التدافع اولا ثم نقوم بحساب التفاضل من هناك ثم نتحرك يشبه الأمر نفس عملية النزول ولكن الفرق انك تترك التدافع ليصل بك إلى مكان ما ثم تبدأ في اختيار خطوتك التالية، يمكنك رؤية هذا في المعادلات التالية

$$ h_t = \alpha h_{t-1} + \eta \frac{\partial}{\partial w}( w_{t-1} - \alpha h_{t-1}) $$

$$ w_t = w_{t-1} - h_t $$

هنا كما سبق نقوم بتحديث الاوزان باستخدام المتغير h كما سبق ولكن الاختلاف في المعادلة الاولى، ولاحظ هنا كيف يتم اخد خطوة في اتجاه التدافع اولا

$$ w_{t-1} - \alpha h_{t-1} $$

و من ثم نرى من عند النقطة الناتجة ما هو افضل اتجاه يمكننا ان نسلكه

$$ \eta \frac{\partial}{\partial w}( w_{t-1} - \alpha h_{t-1}) $$

و نقوم بجمع هذه القيم على مدار خطواتنا مع الأخذ في الاعتبار طبعا معامل الاحتكاك α.
<br />
تعتبر هذه الطريقة اسرع وافضل من التدافع الاعتيادي و سميت باسم نستروف نسبة إلى مخترعها.
</div>

<h2 class="text-right" id="ماذا-عن-معدل-التعلم--η-learning-rate">ماذا عن معدل التعلم  η (learning rate)</h2>

<div dir="rtl">
في الطرق السابقة تلاحظ عدم تطرقنا لمعامل التعلم وهو في الحقيقة مهم جدا، تعالى نرى تأثيره مبدأيا في عملية التعلم.
</div>

<p><img src="/assets/images/gradient-descent-family/lr-types.png" alt="lr-types" class="align-center" /></p>
<center><a href="http://www.bdhammel.com/learning-rates/">المصدر</a></center>

<div dir="rtl">
تذكر ان التغيير الرئيسي للاوزان يحدث من خلال معامل التعلم، لان الاتجاه يأتي من التفاضل، ثم يقوم معدل التعلم بتحديد حجم الخطوة المراد التحرك بها

$$ w_t = w_{t-1} - \eta g_t $$

حيث g هو مقدار التفاضل لذلك فإن معدل التعلم قيمته مهمة جدا إذ ان قيمته اذا زادت فلن نصل إلى الحل الأمثل لان الخطوة المتخذة في الاتجاه الصحيح اكبر بكثير من اللازم و اذا كانت الخطوة صغيرة جدا فسنأخذ الكثير من الوقت حتى نصل إلى النقطة المناسبة إذا نحتاج لإيجاد حل مناسب هنا.
</div>

<p><img src="/assets/images/gradient-descent-family/lg-lr.gif" alt="lg-lr" class="align-center" /></p>

<div dir="rtl">
في الشكل السابق يظهر تأثير معدل التعلم عندما تكون قيمته كبيرة نسبيا فإن خطواته تكون صحيحة في اتجاهها ولكن لان حجم الخطوة كبير فإنه يقفز مسافة طويلة ولا يستقر في المكان الصحيح
</div>

<p><img src="/assets/images/gradient-descent-family/vsm-lr.gif" alt="lg-lr" class="align-center" /></p>

<div dir="rtl">
و هنا نرى انه عندما يكون معدل التغيير صغير للغاية تكون عملية التعلم بطيئة للغاية وبالتأكيد يكون توقف التحرك في المناطق الصغرى المحلية وارد جدا.
</div>

<div dir="rtl">
اذا ما الحل الأمثل؟ هل نختار قيمة صغيرة لمعدل التعلم ام نستخدم قيمة كبيرة له ؟
<br />
في حقيقة الأمر نحن نحتاج كلاهما، نحتاج خطوات كبيرة في بادئ الأمر ثم نتحرك بخطى اصغر كلما تقدمنا في التدريب او التعلم و هذا ما سنتعرض له في الفقرة التالية باستخدام التفاضل التكيفي (Adaptive Gradient AdaGrad)
</div>

<h2 class="text-right" id="التفاضل-التكيفي-adagrad">التفاضل التكيفي (AdaGrad)</h2>

<p><img src="/assets/images/gradient-descent-family/adagrad.png" alt="lg-lr" class="align-center" /></p>
<center><a href="https://g.co/kgs/EQnEFT">المصدر</a></center>

<div rtl="rtl">
هذه المرة سيكون تركيزنا بالأساس مع معامل التعلم (learning rate) وسنعتمد سياسة الإضمحلال بمعنى ان معدل التعلم سيبدأ بقيمة كبيرة ثم يبدأ في النقصان كلما تحركنا، ولكن ليس لكل الاتجاهات بالمثل، ولكن سنعتمد على خطوة مختلفة لكل اتجاه، بمعنى اننا سوف نقلل المعدل للإتجاهات التي بها انزلاق شديد حتى لاتؤثر على الإتجاه العام لانه كما ترى من الرسم اعلاه ان المحور الرأسي ان اتبعنا التفاضل القائم عليه (كما تعلم نحن نقوم بحساب التفاضل على كل اتجاه) واتبعنا خطواته ستجد انه سوف يأخذنا في منحنى بعيد قليلا عن الهدف ثم نبدا بعد ذلك في التحرك للهدف، ولكن باستخدام التفاضل التكيفي سوف نخفض معدل التغير لهذا المحور ونبقى على المحور الاخر بالتالي نتجه ناحية الهدف بشكل اسرع.
</div>

<p><img src="/assets/images/gradient-descent-family/3d-slope.png" alt="lg-lr" class="align-center" /></p>
<center><a href="https://www.cs.umd.edu/~tomg/projects/landscapes/">المصدر</a></center>

<div dir="rtl">
لنستوضح الفكرة بشكل افضل، اذا نظرت إلى الرسم ستجد ان عند النقطة الزرقاء لدينا محور ال Z به انزلاق شديد و اذا اتبعنا التفاضل و كان للاتجاهات معدل تعلم متساوي اذا سوف نذهب في الإتجاه رقم 2 و هو يميل اكثر إلى محور ال Z لان الميل كبير في اتجاهه بالطبع على الرغم من ان الاتجاه رقم 1 اقرب إلى النقطة الأصغر و اسرع ايضا ولكن ما سنقوم بعمله هنا هو ان نخفض معدل التعلم في هذا المحور شديد الانزلاق عن باقي المحاور، اذا دعنا نرى كيف يتم ذلك رياضيا.
</div>

<div dir="rtl">
سوف نقوم بعريف متغير G و هو مجموع تربيع التفاضلات لكل اتجاه

$$ G_j^t = G_j^{t-1} + g_{tj}^2 $$

دعنا نستوضح المعادلة قليلا، هنا الرمز j يعبر عن الاتجاه بالتالي لكل اتجاه G مختلف و بالطبع g مختلف (g تعبر عن التفاضل في هذه اللحظة/المرة) ثم لدينا t و هي تعبر عن مرات التمرين.
<br />
اذا ما يحتويه G هو محصلة التفاضلات السابقة لهذا الاتجاه وسيصبح لدينا معلومة عن ماضي تفاضلات هذا الاتجاه و كلما كان الاتجاه منحدر اكثر (مثل اتجاه Z في مثالنا السابق) كلما كان مقدار ماضيه التفاضلي G اكبر بكثير.
<br />
و الان دعنا نرى كيف يمكننا تغيير معامل التعلم لكل اتجاه مع الاخذ في عين الاعتبار ماضيه التفاضلي

$$ w_j^{t} = w_j^{t-1} - \frac{\eta}{\sqrt{G_j^t + \epsilon}} g_{tj} $$

كما ترى هنا، كل وزن له تحديث خاص به وله معامل تعلم خاص به ايضا حيث يتم تخفيض معدل تعليمه بما هو قيمته 
$$ \sqrt{G_j^t + \epsilon} $$

هنا المعامل ϵ يستخدم حتى لايكون المقام في عملية القسمة بصفر و تكون قيمته صغيرة جدا
<br />
و تلاحظ ايضا انه عند زيادة G لهذا الاتجاه فإن الخطوة التي يتخذها ستكون اصغر مع الوقت و قد تصل إلى ان تتوقف تماما وهذا احد عيوب هذا الطريقة في الحقيقة.
</div>

<h2 class="text-right" id="الانتشار-المتوسط-للجذر-التربيعي-rmsprob---root-mean-square-propagation">الانتشار المتوسط للجذر التربيعي (RMSprob - Root Mean Square Propagation)</h2>

<div dir="rtl">
هذه الطريقة تم تقديمها من خلال الدكتور جيفري هينتون في محاضرته السادسة في الكورس الذي يقدمه على منصة التعلم Coursera ولم تصدر به ورقة بحثية، لكن معظم الباحثين يشيروا اليه عن طريق رابط الكورس.
</div>

<div dir="rtl">
الفكرة هذه المرة هي ان نمنع الطريقة التكيفية من ان توقف التعلم بشكل كلي لان كما رأينا من قبل يمكن لمعدل التعلم ان يقل بشكل شديد حتى يختفي، لذلك هنا نقدم طريقة مختلفة لحساب التاريخ/السجل التفاضلي للمتغير عن طريق ان نقلل معدل التراكم كما سنرى في المعادلة الآتية.

$$ G_j^t = \alpha G_j^{t-1} + (1-\alpha) g_{tj}^2 $$

في غالب الامر تكون قيمة α 0.9 وبالتالي يكون الإعتماد على التاريخ التفاضلي بنسبة 0.9 و على القيمة الحالية للتفاضل بنسبة 0.1 و هكذا يقل معدل التراكم قليلا ونحافظ على ميزة التفاضل التكيفي اذ تظل معادلة تحديث الأوزان كما هي.

$$ w_j^{t} = w_j^{t-1} - \frac{\eta_t}{\sqrt{G_j^t + \epsilon}} g_{tj} $$
</div>

<h2 class="text-right" id="التقدير-التكيفي-اللحظي-adam---adaptive-moment-estimation">التقدير التكيفي اللحظي (Adam - Adaptive moment estimation)</h2>

<div dir="rtl">
حتى الآن تعرضنا لكيفية ضبط معدل التكيف على حدى و طريقة لضبط اتجاه التفاضل على حدى، الآن سنقوم بدمجهما معا في خوارزمية واحدة كما سنرى الآن.
</div>

<div dir="rtl">
تعتمد طريقة Adam على ان نستخدم معامل التعلم التكيفي الذي يقل تدريجيا في المواضع الاكثر انحدارا و ايضا ان نستخدم خاصية قوة الدفع وبالتالي نحصل على كلا الميزتين في طريقة واحدة، دعنا نستعرض المعادلات.

$$ m_j^t = \frac{\beta_1 m_j^{t-1} + (1-\beta_1) g_j^t}{1 - (\beta_1)^t} $$

$$ v_j^t = \frac{\beta_2 v_j^{t-1} + (1-\beta_2) g_j^t}{1 - (\beta_2)^t} $$

$$ w_j^t = w_j^{t-1} - \frac{\eta}{\sqrt{v_j^t}+ \epsilon} m_j^t $$

تجد في المعادلة الاخيرة ان الاوزان يتم تحديثها باستعواض m بدل من التفاضل العادي و كذلك يتم تخفيص معامل التعلم بمقدار المعامل v و اللذان يتم حسابهم باستخدام نفس المعادلة تقريبا، وستجد ان كلا المعادلتان في البسط هما عبارة عن احتفاظ بتاريخ الخطوات سواء m او v ولكن بمعامل β والذي يحدد ما إذا كنت تريد ان تعتمد على قيمة الماضي ام الحاضر اكثر

$$ \beta_1 m_j^{t-1} + (1-\beta_1) g_j^t $$

لاحظ هنا ان β مختلفة لكل معامل و غالبا ماتكون قيمتمها حوالي 0.9.
</div>

<div dir="rtl">
اذا الاختلاف في المقام الجديد (1-β) و هو في الحقيقة مستخدم لدفع العملية في خطواتها الأولى اذ انه مثلا في الخطوة الأولى عند t=1 وباستخدام β=0.9 سيكون قيمة المقام هي

$$ (1-\beta^t) = (1 - (0.9)^2) = (1-0.81) = 0.19 $$

اذا يتم قسمة المعامل m و v بقيمة 0.19 و هي كأنك ضاعفت مقداره 5 مرات

$$ \frac{1}{1-\beta^t} = \frac{1}{0.19} = 5.26 $$

وهكذا يتم دفع المعاملات في بداية التعلم لان قيمتهم في البداية ستكون قريبة من الصفر.
</div>

<h2 class="text-right" id="اشكال-توضيحية">اشكال توضيحية</h2>

<div dir="rtl">
في الأشكال الآتية نرى مقارنة بين انواع مختلفة من خوارزميات النزول التدريجي و كيف ان بعضهم مناسب في احيان و بعضهم الاخر في احيان.
</div>

<p><img src="https://ruder.io/content/images/2016/09/saddle_point_evaluation_optimizers.gif" alt="lg-lr" class="align-center" /></p>
<center><a href="https://ruder.io/optimizing-gradient-descent/index.html">المصدر</a></center>

<p><img src="https://github.com/Jaewan-Yun/optimizer-visualization/raw/master/figures/movie11.gif" alt="lg-lr" class="align-center" /></p>
<center><a href="https://github.com/Jaewan-Yun/optimizer-visualization">المصدر</a></center>

<p><img src="https://github.com/Jaewan-Yun/optimizer-visualization/raw/master/figures/movie9.gif" alt="lg-lr" class="align-center" /></p>
<center><a href="https://github.com/Jaewan-Yun/optimizer-visualization">المصدر</a></center>

<dev dir="rtl">
لاحظ اختلاف تصرف الخوارزميات بإختلاف طبيعة الدالة المراد حلها.
<br />
يمكنك ايضا الاتطلاع على الكود المصدري للرسومات من خلال <a href="https://github.com/Jaewan-Yun/optimizer-visualization">هذا الرابط</a>
</dev>

<h2 class="text-right" id="الاستنتاج">الاستنتاج</h2>

<div dir="rtl">
في هذا المقال تحدثنا عن انواع مختلفة من عائلة النزول التدريجي و اوجه الاختلاف بينهم وما الذي يميز كل واحد منهم.
</div>

<div dir="rtl">
لا يوجد طريقة افضل في المطلق من بينهم ولكن غالبا ما ستجد نفسك تقوم بالتجارب باستخدام اكثر من واحد ولكن من افضلهم Adam لهذا يمكنك ان تبدأ به و ترى أين سيقودك.
</div>

<div dir="rtl">
هناك انواع اخرى من Adam مثل Adamax و Adadelta و Nadam لم نقم بالتعرض لهم في مقالنا هنا ولكن فكرتهم ليست ببعيدة عما قمنا بشرحه، يمكنك الإطلاع عليهم من خلال <a href="https://ruder.io/optimizing-gradient-descent/index.html">هذا المقال الرائع</a>
</div>

<div dir="rtl" class="notice--success">
في هذا المقال حاولت تبسيط بعض المصطلحات للغتنا العربية من اجل تسهيل عملية الشرح ولتبسيط المعلومة، في حالة اي خطأ املائي او اقتراح افضل للترجمة فأنا ارحب جدا بذلك يمكنك التعليق على المقال او مراسلتي لتعديل و تحسين المحتوى، ووفقنا الله وإياكم لما يحب ويرضى.
</div>

<h2 class="text-right" id="مصادر">مصادر</h2>

<div dir="rtl">
<ul>
<li><a href="https://www.researchgate.net/publication/243648538_Some_methods_of_speeding_up_the_convergence_of_iteration_methods">بوريس بولياك و اقتراح طريقة التدافع لتسريع عملية التعلم</a></li>
<li><a href="https://scholar.google.com/scholar?q=A+method+for+solving+the+convex+programming+problem+with+convergence+rate+author%3Anesterov">طريقة نستروف في تحديث الاوزان</a></li>
<li><a href="http://jmlr.org/papers/v12/duchi11a">استخدام التفاضل التكيفي للتعلم المستمر</a></li>
<li><a href="https://www.youtube.com/watch?v=defQQqkXEfE&amp;list=PLoRl3Ht4JOcdU872GhiYWf6jwrk_SNhz9&amp;index=29">محاضرة جيفري هينتون عن RMSprop</a></li>
<li><a href="https://www.coursera.org/lecture/intro-to-deep-learning/gradient-descent-extensions-lYGBt">نبذه عن امتدادات النزول التدريجي من جامعة HSE </a></li>
<li><a href="https://arxiv.org/abs/1412.6980">الورقة البحثية الخاصة ب Adam</a></li>
<li><a href="https://www.amazon.com/Hands-Machine-Learning-Scikit-Learn-TensorFlow/dp/1492032646/ref=pd_lpo_14_img_0/144-0573287-0625952?_encoding=UTF8&amp;pd_rd_i=1492032646&amp;pd_rd_r=27b1bb81-58a0-4b99-98b4-e030eeabcd73&amp;pd_rd_w=yj1vf&amp;pd_rd_wg=NeBK7&amp;pf_rd_p=7b36d496-f366-4631-94d3-61b87b52511b&amp;pf_rd_r=6Y4YBDC2CNC8E3S2M518&amp;psc=1&amp;refRID=6Y4YBDC2CNC8E3S2M518">كتاب machine learning hands-on الرائع</a></li>
</ul>
</div>]]></content><author><name>Ali Abdelaal</name></author><category term="Blog" /><category term="arabic" /><category term="optimization" /><category term="machine learning" /><summary type="html"><![CDATA[في هذا المقال نتعرض لبعض خصائص النزول التدريجي و مشاكله و كيفية حلها باستخدام مشتقاته]]></summary></entry><entry><title type="html">مقدمة في علم الآلة</title><link href="/blog/intro-to-ml/" rel="alternate" type="text/html" title="مقدمة في علم الآلة" /><published>2020-05-15T00:00:00+00:00</published><updated>2020-05-15T00:00:00+00:00</updated><id>/blog/intro-to-ml</id><content type="html" xml:base="/blog/intro-to-ml/"><![CDATA[<script src="https://formspree.io/js/formbutton-v1.min.js" defer=""></script>

<script>
   window.formbutton=window.formbutton||function(){(formbutton.q=formbutton.q||[]).push(arguments)};
   formbutton("create", {
     title: "Hello there 👋",
     description: "Subscribe for my new content, or drop a message 🥳",
     action: "https://formspree.io/xbjzaerk",
     theme: "classic",
     fields: [{
      name: "name",
      type: "text",
      label: "Your Name",
      required: true,
      placeholder: "Say your name 🤔"
    },
    {
      name: "email",
      type: "email",
      label: "Your Email",
      placeholder: "Enter your em@il 📬",
      required: true
    },
    {
      name: "Message",
      type: "textarea",
      placeholder: "drop a message ! 🤓 if you want to 🤷‍♂️"
    },
    {
      type: "submit"
    }],
     })
</script>

<div dir="rtl">
مجال تعلم الآلة او (machine learning) هو احد فروع الذكاء الاصطناعي و يشتمل بداخله علم التعلم العميق (deep learning) 
</div>

<p><img src="/assets/images/intro-to-ml/ai-and-ml.png" alt="ai-vs-ml" class="align-center" /></p>

<div dir="rtl">
و عرفه العالم آرثر سامويل 
</div>

<div dir="rtl" class="notice--info">
ان تعطي اجهزة الكمبيوتر القدرة على التعلم بدون ان تتم برمجتها بشكل صريح
<br />
<cite><a href="https://www.wikiwand.com/simple/Machine_learning">المصدر</a></cite>
</div>

<div dir="rtl">
لتوضيح هذا العنوان بشكل افضل، لنستعرض الفرق بين البرمجة الحرفية و تعليم الآلة بشكل مبسط
</div>

<h2 class="text-right" id="البرمجة-التقليدية-الحرفية">البرمجة التقليدية (الحرفية)</h2>

<div dir="rtl">
لنقل على سبيل المثال اننا نود ان نميز بين اذا ما كان في الصورة قطة ام لا

<center><img src="https://images.unsplash.com/photo-1520315342629-6ea920342047?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1000&amp;q=80" /></center>
<center><a href="https://images.unsplash.com/photo-1520315342629-6ea920342047?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1000&amp;q=80">المصدر</a></center>

ففي حالة البرمجة التقليدية سوف نقوم بوضع جميع القواعد التي تحتاجها الآلة حتى تميز هذا القطة مثل ان اذنها يجب ان تكون مثلثة الشكل قليلا و ان وجهها يجب ان يكون دائريا نوعا ما و ايضا ان تحتوى على فراء، وهكذا إلى اخر القواعد التي يمكنك كتابتها
<br />
وفي حالة ان احد هذه القواعد لم تماثل ماقمت بتعريفه لن نتمكن من ان نتعرف على القطة في الصورة للاسف.
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">ear</span> <span class="ow">is</span> <span class="n">triangle</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">face</span> <span class="ow">is</span> <span class="n">circular</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">object</span> <span class="n">has</span> <span class="n">furr</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="n">cute</span><span class="p">:</span>
          <span class="s">"it's a cat!"</span>
</code></pre></div></div>

<p><img src="/assets/images/intro-to-ml/rule-based.png" alt="rule-based" class="align-center" /></p>

<div dir="rtl">
بالطبع يمكنك الملاحظة ان هنا لن نتمكن من تغطية جميع المواصفات التي تميز القط، ناهيك عن اختلاف القرب او البعد عن الصورة على سبيل المثال او تغيير مكان القطة في الصورة او حتى طريقة تحديد هذه المواصفات
<br />
بالتالي هذه ليست الطريقة الافضل في هذه المهمة، لذا تعالى معي نستعرض الطريقة الاخرى و هي باستخدام تعليم الآلة
</div>

<h2 class="text-right" id="طريقة-تعليم-الآلة-التعلم-من-البيانات">طريقة تعليم الآلة (التعلم من البيانات)</h2>

<div dir="rtl">
في هذه الطريقة نعتمد بالاساس على ان نوفر صور مختلفة لقطط و اي شئ غير القطط و نترك الامر لما سوف ندعوه <b>نموذج</b> كي يتعلم ماهية القط و كيف يمكنه تمييزه عن غيرها من الاشياء.
<br />
بالطبع هذه الطريقة تعتمد على ان يتوفر صور عدة للقطط وكذلك لغير القطط حتى يتمكن نوذجنا من معرفة القط من غيره و من هذا المنطلق تنشأ الحاجة الى كثير من البيانات حتى نتمكن من عمل نوذج قوي يمكنه التمييز، و توفر البيانات بكثرة في العقد الاخير سمح بتقدم هائل في مجال تعلم الآلة والذكاء الصناعي بشكل عام.
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cats</span> <span class="o">=</span> <span class="p">[</span><span class="n">cat1</span><span class="p">,</span> <span class="n">cat2</span><span class="p">,</span> <span class="n">cat3</span><span class="p">,</span> <span class="p">...]</span>
<span class="n">machine_learning_model</span><span class="p">.</span><span class="n">learn_from</span><span class="p">(</span><span class="n">cats</span><span class="p">)</span>
<span class="n">machine_learning_model</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">new_image</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/intro-to-ml/ml-based.png" alt="ml-based" class="align-center" /></p>

<div dir="rtl">
حسنا عرفنا الآن الفرق الاساسي بين التعلم من البيانات و الطرق المعتمدة على البيانات التي يطلق عليها (data driven approaches) وكذلك الطرق التي تعتمد على ان نعطيها القواعد التي تم تصميمها يدويا (rule based approaches).
<br />
ولكن كيف للآلة ان تتعلم هكذا صفات؟ و ان تفهم النمط المتواجد في البيانات و بناءا عليه تمييز البيانات الجديدة التي لم يراها من قبل؟
<br />
لنفهم هذا دعنا ننظر الى مثال بسيط في هذا الشأن
</div>

<h2 class="text-right" id="استخراج-النمط-من-البيانات">استخراج النمط من البيانات</h2>

<div dir="rtl">
لنقل على سبيل المثال ان لديك منزل تريد ان تبيعه، ولا تعرف اي سعر قد يكون مناسب لك و لكنك تعلم ان اخر 3 بيوت تم بيعهم في المنطقة المحيطة لك كانت اسعارهم و مواصفاتهم كالاتى
</div>

<table>
  <tbody>
    <tr>
      <td align="center">الطابق الواقع فيه المنزل<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>    
        <span>&nbsp;&nbsp;</span>
      </td>
      <td align="center">مساحة المنزل<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>        
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;</span>
      </td>
      <td align="center">سعر البيع<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>    
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>     
        <span>&nbsp;&nbsp;</span>        
      </td>
    </tr>
    <tr>
        <td align="center">الثالث<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>    
        <span>&nbsp;&nbsp;</span>
      </td>
      <td align="center">300<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>        
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;</span>
      </td>
      <td align="center">9300<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>    
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>     
        <span>&nbsp;&nbsp;</span>        
      </td>
    </tr>
    <tr>
      <td align="center">الاول<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>    
        <span>&nbsp;&nbsp;</span>
      </td>
      <td align="center">250<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>        
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;</span>
      </td>
      <td align="center">7600<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>    
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>     
        <span>&nbsp;&nbsp;</span>        
      </td>
    </tr>
        <tr>
      <td align="center">الخامس<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>    
        <span>&nbsp;&nbsp;</span>
      </td>
      <td align="center">100<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>        
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;</span>
      </td>
      <td align="center">800<br />
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>    
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
        <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>     
        <span>&nbsp;&nbsp;</span>        
      </td>
    </tr>

  </tbody>
</table>

<div dir="rtl">
و لديك مواصفات منزلك و الذي يقع في <b>الطابق الثاني</b> و مساحته <b>220</b> اذا ما هو السعر المناسب لمنزلك؟
<br />
بالطبع يمكننا ان نقوم بتحويل هذه المسألة إلى معادلات في متغيريين كما يلي
<br />
اذا اعتبرنا ان الطابق هو متغير X و ان المساحة هي متغير Y اذا يمكننا ان نصف اول منزلين كما يلي 
</div>

\[3X + 300Y = 9300\]

\[1X + 250Y = 7600\]

<div dir="rtl">
نستطيع حل هاتان المعادلتان سويا و استخراج X بدلالة Y ثم ايجاد قيمتهما سويا كما يلي
</div>

\[\because X = 7600 - 250 Y\]

\[\therefore 3 (7600 - 250 Y) + 300 Y = 9300\]

\[\therefore Y = 30\]

\[\therefore X = (7600 - 250 * 30) = 100\]

<div dir="rtl">
و هكذا يمكننا ان نحسب ثمن المنزل الذي نريد ان نبيعه كالتالي
</div>

\[100 * 2 + 30 * 220 = 6800\]

<div dir="rtl">
هنا يمكنك تفسير قيمة X و Y على انهم اهمية الطابق الذي تقع .فيه الشقة و مساحتها على الترتيب
<br />
<br />
بالتالي هنا نرى ان اهمية الطابق قيمتها 100 و اهمية المساحة قيمتها 30.
<br />
<br />
ما فعلناه للتو هو تخصيص ما يسمى <b>اوزان او(weights)</b> للمتغيرات او الخصائص التي لدينا وهي الطابق و المساحة، وهذا هو المبدأ الأساسي الذي تقوم عليه عملية التعلم اذ نقوم بتخصيص وزن لكل متغير يصف البيت او ما يسمى (feature) و نقوم بحساب هذه الاوزان.
<br />
دعنا نرى كيف تقوم الآلة بعمل هذه العملية.
</div>

<h2 class="text-right" id="كيفية-حساب-الاوزان">كيفية حساب الاوزان</h2>

<div dir="rtl">
لنكمل على المثال السابق، دعنا نقول ان المنزل يتم توصيفه بعدد من المتغيرات N، مثل مساحته، الطابق، المحافظة ، وهكذا.
<br />
و ان لدينا عدد m من المنازل وهي التي سنقوم من خلالها بحساب الاوزان الخاصة بكل متغير وسوف نرمز لهذه الاوزان برمز W اذا دعنا نرى المعادلة الخاصة بالمنزل رقم i والذي سعره Y
</div>

\[w_1 x_{1}^{(i)} + w_2 x_{2}^{(i)} + w_3 x_{3}^{(i)} + .... + w_n x_{n}^{(i)} = y^{(i)}\]

<div dir="rtl">
في هذه المعادلة يمكنك ان ترى ان كل خاصية في المنزل مخصص لها وزن محدد و ان تكلفة المنزل هي محصلة ضرب كل وزن في الخاصية المحدد لها، وطبعا لن يمكننا حساب هذه الاوزان عن طريق معادلة واحدة، وانما عدد m من المعادلات، و الذي هو عدد المنازل كما تذكر
</div>

\[w_1 x_{1}^{(1)} + w_2 x_{2}^{(1)} + w_3 x_{3}^{(1)} + .... + w_n x_{n}^{(1)} = y^{(1)}\]

\[w_1 x_{1}^{(2)} + w_2 x_{2}^{(2)} + w_3 x_{3}^{(2)} + .... + w_n x_{n}^{(2)} = y^{(2)}\]

\[...\]

\[w_1 x_{1}^{(m)} + w_2 x_{2}^{(m)} + w_3 x_{3}^{(m)} + .... + w_n x_{n}^{(m)} = y^{(m)}\]

<div dir="rtl">
الآن كيف نقوم بحساب هذه المتغيرات؟، بالطبع يمكننا حسابه بنفس الطريقة التي قمنا بها بالاعلى، إلا ان هذه الطريقة سوف تكون مكلفة حسابيا بشكل كبير و ربما نتعرض في مقال اخر لمدى تعقيدها، ولكن لحسن الحظ هناك طريقة اخرى اكثر فعالية و اسرع في حسابها و هي النزول التدريجي او (gradient descent)
<br />
لنفهم هذه الطريقة دعنا نقوم بتعريف المشكلة بشكل اخر.
</div>

<h2 class="text-right" id="النزول-التدريجي-gradient-descent">النزول التدريجي (gradient descent)</h2>

<h3 class="text-right" id="توصيف-المشكلة">توصيف المشكلة</h3>

<div dir="rtl">
دعنا الان نعبر عن المشكلة بشكل افضل، كما هو موضح بالشكل ادناه.
</div>

<p><img src="/assets/images/intro-to-ml/formula-1.png" alt="formula-1" class="align-center" /></p>

<div dir="rtl">
سنتبع طريقة لذيذة هنا، دعنا نخمن ما هي افضل قيمة للاوزان و لنقل مثلا صفر و نرى كيف سنتكون النتيجة؟
</div>

<p><img src="/assets/images/intro-to-ml/formula-2.png" alt="formula-1" class="align-center" /></p>

<div dir="rtl">
كما يمكنك ان ترى، جميع المنازل الان صار سعرها صفر لان ببساطة كل منزل يتم حساب سعره كما يلي
</div>

\[0 * x_{1}^{(i)} + 0 * x_{2}^{(i)} + 0 * x_{3}^{(i)} + .... + 0 x_{n}^{(i)} = \hat{y} = 0\]

<center><p dir="rtl" class="notice--primary">الرمز Y^ يعبر عن التوقعات</p></center>

<div dir="rtl">
اذا صفر ليس القيمة الصحيحة للاوزان و نحتاج الى تغيرها، اذا ما الرقم الذي نحتاجه؟ و ما هو الرقم الافضل لكل متغير؟
<br />
في البداية دعنا نرى مدى الخطأ الذي ادى اليه الصفر ثم ننظر كيف يمكننا ان نقلل هذا الخطأ تدريجيا اذا، ولحساب هذا الخطأ سوف نستخدم الفرق بين توقعنا والسعر الصحيح ولاننا يمكن في مرحلة ما ان يصبح لدينا قيم سالبة سوف نرفع القيمة للأس الثاني كما هو موضح بالمعادلة ادناه
</div>

\[Error^{i} = ( \hat{y}^{i} - y^{i})^{2}\]

<div dir="rtl">
هذه هي معادلة الخطأ لنقطة واحدة، فمثلا في حالتنا هذه يصبح الخطأ في أول مثال قيمته كالتالي
</div>

\[Error^{1} = ( \hat{y}^{1} - y^{1})^{2} = (0 - 7800)^{2} = 60840000\]

<div dir="rtl">
و هكذا نحتاج لمعرفة الخطا على مستوى جميع المنازل التي لدينا والتي عددها m كما قلنا من قبل، لذلك سوف نقوم بحساب حاصل جمع كل الاخطاء على مستوى المنازل كلها و كما ترى لان الرقم كبير نسبيا سوف نقوم بأخذ المتوسط لهذه المحصلة ليصبح الرقم اقل قليلا ولكن مازال معبرا عن الخطأ فقط ابسط في الحسابات
</div>

\[Error = \frac{1}{2m} \sum_{i=1}^{m} (\hat{y}^{i} - y^{i})^2\]

<div dir="rtl">
الان اصبح لديك معادلة تعبر عن مدى الخطأ في توقعاتنا ومدى بعد توقعاتنا عن الصواب بالتالي كلما قلت هذه المعادلة كقيمة كلما كانت توقعاتنا صحيحة لان عندما تكون التوقعات سليمة يصبح $$ \hat{Y} - Y = 0$$و بالتالي سيصبح الخطأ الكلي صفر
<br />
اذا هدفنا الان هو ان نصل لطريقة تمكننا من تقليل قيمة هذه المعادلة وهنا يأتي دور التفاضل اذا كنت تذكره، ان لم تكن تذكره فسوف نتذكره سويا في الفقرة التالية
</div>

<h3 class="text-right" id="تطبيق-التفاضل-في-تعلم-الآلة">تطبيق التفاضل في تعلم الآلة</h3>

<div dir="rtl">
تفاضل دالة ما هو معدل تغير قيمتها بالنسبة لمتغير من متغيراتها فعلى سبيل المثال في الدالة الآتية عندما نقوم بحساب معدل تغير Y بالنسبة ل X نحن نقوم بطرح سؤال و هو اذا قمنا بتغيير قيمة X كم ستتأثر Y و ايضا يمكننا طرح سؤال اخر و هو اين اتجاه زيادة قيمة Y بالنسبة ل X بمعنى، هل نحتاج ان نرفع قيمة X ام نخفضها حتى تزيد قيمة Y
</div>

<p><img src="/assets/images/intro-to-ml/graph-1.png" alt="graph-1" class="align-center" /></p>

<div dir="rtl">
$$ y = x^2 $$
اذا كنت تتذكر قواعد التفاضل فانك ستتذكر ان تفاضل هذه الدالة هو 2x
$$ \frac{d}{dx} = 2x $$
و قد تلاحظ هنا ان التفاضل يحتوي على متغير، اي ان قيمة التفاضل تختلف بختلاف مكانك في الدالة و اذا قمنا باختبار ذلك في موضعين مختلفين في الدالة على سبيل المثال سنجد ان قيمة التفاضل بالفعل تختلف لنرى كيف 
<br />
<br />
التفاضل يمكن حسابه عن طريق الميل او ال (slope) بين نقطتين في الدالة و سوف نقوم بحساب التغيير بناءا على ذلك اولا بين نقطتين هما 
<center><div dir="ltr">
(7, 49), (8, 64)
</div></center>
$$ Slope = \frac{y_1-y_2}{x_1-x_2} = \frac{49-64}{7-8} = 15 $$
اذا معدل التغيير هنا هو 15 و ايضا كما تلاحظ 2x حيث x = 7.5
<br />
و الان لنرى قيمة التفاضل بين نقطتين اخرتيين  
<center>(1, 1), (2, 4)<div>
</div></center>
$$ Slope = \frac{y_1-y_2}{x_1-x_2} = \frac{1-4}{1-2} = 3 $$
سنجد ان معدل التغير اختلف عن المكان السابق و قيمته هنا 3
</div>

<div dir="rtl">
نسنتنج مما سبق ان معدل التغير في الدالة يختلف من مكان لاخر بها و لذلك يوجد متغير x في معادلة التفاضل و ايضا نستطيع ان نرى مما سبق ان التفاضل عند النقتطين كان قيمته موجبة اي ان مع زيادة X سوف تزداد قيمة Y على عكس اذا ما حسبنا التفاضل بين نقطتين سالبتين مثلا
<center><div dir="ltr">
(-2, -4) (-1, -1)
</div></center>
$$ Slope = \frac{y_1-y_2}{x_1-x_2} = \frac{-4+1}{-2+1} = -3 $$
نجد في الجزء السالب من هذه الدالة ان زيادة X سوف تقلل من قيمة Y ولهذا يظهر التفاضل بقيمة سالبة
</div>

<p><img src="/assets/images/intro-to-ml/graph-2.png" alt="graph-1" class="align-center" /></p>

<div dir="rtl">
اذا التفاضل يمكنه اخبارنا اين هو اتجاه زيادة الدالة بالنسبة لمتغير معين وبالتالي فإن عكس هذا الاتجاه سيكون هو اتجاه النقصان، اذا عند اي نقطة في الدالة اذا فاضلناها سنعلم اي اتجاه نحتاج ان نسير اليه لتقليل قيمة هذه الدالة وهذا ايضا ليس لمتغير واحد وانما لاكثر متغير اذ انه يمكنك ان تفاضل الدالة لاكثر من متغير و سوف تحصل على اتجاه الزيادة لكل متغير، اذا كنت تتساءل عن شكل الدالة في حالة ان بها اكثر من متغيرين فهي كالشكل الآتي
</div>

<p><img src="https://users.cs.duke.edu/~rongge/images/nonconvex.PNG" alt="graph-1" class="align-center" /></p>
<center><a href="https://users.cs.duke.edu/~rongge/images/nonconvex.PNG">المصدر</a></center>

<div dir="rtl">
في هذه الحالة نقوم بحساب التفاضل بالنسبة لكل متغير على حدى و نرى لكل متغير على حدى ما علاقته بالدالة بشكل عام وما التغيير الذي نحتاج ان نقوم به حتى تزداد الدالة بشكل عام فبالتالي نستطيع ان نوجد اتجاه نقصانها
</div>

<h3 class="text-right" id="كيفية-استخدام-التفاضل-في-تحسين-توقعاتنا">كيفية استخدام التفاضل في تحسين توقعاتنا</h3>

<div dir="rtl">
الآن لدينا مجموعة من الاوزان (weights) التي خصصناها لمجموعة من ال (features) او الخصائص التي من المفترض ان من خلالها سنستطيع ان نستنتج سعر اي منزل جديد، ولدينا ايضا معادلة الخطا التي تقيم مدى قربنا او بعدنا عن الصواب و الذي هو بدوره تقييم للاوزان نفسها كما رأينا في مثال الصفر بالأعلى

$$ Error = \frac{1}{2m} \sum_{i=1}^{m} (\hat{y}^{i} - y^{i})^2 $$

وبالنظر إلى المعادلة التي استنتجنا منها Y^ سنجد انها معادلة في الاوزان بالاساس

$$ w_1 x_{1}^{(i)} + w_2 x_{2}^{(i)} + w_3 x_{3}^{(i)} + .... + w_n x_{n}^{(i)} = y^{(i)} $$

واذا عبرنا عن الاوزان كلها ب W و الخصائص كلها ب X يمكننا التعبير عن نوذجنا كالتالي

$$ W*X = \hat{Y} $$

بالتالي معادلة الخطأ تصبح

$$ Error = \frac{1}{2m} \sum_{i}^{m} ( W*x^{i} - y^{i})^2 $$

الان يمكننا استخدام التفاضل لنوجد اتجاه الزيادة لهذه المعادلة و بالتالي عكسه سوف يكون اتجاه النقصان و بالتالي يمكننا ان نعدل كل وزن ليسير في اتجاه النقصان الخاص بالدالة.

$$ \frac{d}{dW} Error = \frac{1}{m} \sum_{i}^{m} (W*x^{i} - y^{i})x^{i}$$

<br />
تعال معي نستوضح الموضوع بشكل ابسط
</div>

<p><img src="/assets/images/intro-to-ml/graph-3.png" alt="graph-1" class="align-center" /></p>

<div dir="rtl">
في هذا الرسم نوضح العلاقة بين الخطأ و احد الاوزان ونرى هنا ان عند تغيير الوزن نحصل على قيم مختلفة للخطأ و كذلك يوجد لكل وزن المستوى الخاص به و اذا جمعنا الاوزان كلها سوف ننتهي برسم اشبه بالشكل الآتي ولكن في ابعاد اكثر لا يمكن رسمها
</div>

<p><img src="https://miro.medium.com/max/1000/0*1DCc3JBWmSMlt-0r.png" alt="graph-1" class="align-center" /></p>
<center><a href="https://miro.medium.com/max/1000/0*1DCc3JBWmSMlt-0r.png">المصدر</a></center>

<div dir="rtl">
الان وبفضل التفاضل يمكننا ان نحدث قيمة الوزن في الاتجاه الذي ينقص الدالة الكلية و هو الاتجاه المعاكس للتفاضل الذي حسبناه بالاعلى وبالتالي يمكننا بعد حساب الخطا ان نحدث قيمة الوزن كما يلي

$$ W_t = W_{t-1} - \eta \frac{d}{dW}Error $$

هنا يمكنك ان ترى اننا نحدث قيمة الوزن الجديد بان يصبح الوزن القديم طرح التفاضل مضروب بمعامل η و هو يعبر عن مستوى التعلم او (learning rate) و سوف نتعرض له في مقال اخر بإذن الله
<br />
وهكذا تتغير قيمة الاوزان لتصبح قيمة جديدة تتسبب في انخفاض الخطأ بشكل عام.
</div>

<h2 class="text-right" id="الشكل-الكلي">الشكل الكلي</h2>

<p><img src="/assets/images/intro-to-ml/graph-4.png" alt="graph-1" class="align-center" /></p>

<div dir="rtl">
اذا هذا هو تسلسل خطوات النوذج الذي قمنا ببنائه للتو
<ul>
<li>تخصيص وزن لكل خاصية</li>
<li>ابتداء قيمة هذه الاوزان بصفر او الافضل ان نبدأهم بقيم عشوائية</li>
<li>حساب التوقات بناءا على هذه الاوزان</li>
<li>حساب الخطأ من هذه التوقعات</li>
<li>حساب التفاضل بالنسبة لكل وزن وايجاد اتجاه النقصان لكل منهم</li>
<li>تحديث الاوزان و الرجوع للنقطة الثالثة</li>
</ul>

يمكنم ان ترى ان هذه السلسلة قد تستمر للأبد، ولكن يتم وضع شروط للتوقف مثل ان تمر بهذه العملية عدد معين من المرات او ان يكون التغيير في معادلة الخطأ اقل من قيمة معينة.
</div>

<div dir="rtl">
تسمى هذه العملية بالتدريب او التعلم (training/learning) و بعد انتهاء هذه العملية يصبح لدينا اوزان للمتغيرات التي لدينا و يمكننا بناءا عليها ان نتوقع سعر اي منزل قادم بأن نقوم بإدخال متغيرات المنزل في معادلتنا الاساسية بعد حساب الاوزان

$$ w_1 x_{1}^{(i)} + w_2 x_{2}^{(i)} + w_3 x_{3}^{(i)} + .... + w_n x_{n}^{(i)} = y^{(i)} $$
</div>

<h2 class="text-right" id="اشكال-اخرى-لتعلم-الآلة">اشكال اخرى لتعلم الآلة</h2>

<div dir="rtl">
ما قمنا بتغطيته للتو هو نوع من انواع تعلم الآلة حيث يكون ما نحاول توقعه قيمة مستمرة يمكن ان تكون اي رقم من سالب مالانهاية إلى مالانهاية و يسمى هذا النوع من النماذج بإسم (regression models) و لكن هذا ليس النوع الوحيد يوجد انواع اخرى تقع جميعها تحت مسمى التعلم تحت الاشراف (suprevised learning)، و هو باختصار وجود بيانات صحيحة نحاول التعلم منها.
<br />
وهنا بعض انواع نماذج تعلم الآلة
<ul>
  <li>التعلم بإشراف (suprevised learning) حيث يتواجد امثلة و يتواجد ايضا التوقع الصحيح لها
    <ul>
      <li>Regression حيث التوقعات يمكن ان تكون قيم مستمرة</li>
      <li>Classification حيث التوقعات يمكن انت تكون بين قيم محددة مثل قط او كلب </li>
    </ul>
  </li>
  <li>التعلم بدون اشراف (unsuprevised learning) حيث يتواجد امثلة ولكن لا يوجد توقع صحيح لها
    <ul>
      <li>Clustering حيث نقوم بإيجاد مجموعات متشابهة داخل البيانات</li>
    </ul>
  </li>
</ul>
</div>

<h2 class="text-right" id="الاستنتاج">الاستنتاج</h2>

<div dir="rtl">
في هذا المقال تعرضنا بشكل بسيط لماهية تعلم الآلة وكيف يمكن للآلة ان تتعلم من البيانات بشكل مبسط وبتغطية مايوجد خلف مصطلح تعلم الآلة
</div>

<div dir="rtl" class="notice--success">
في هذا المقال حاولت تبسيط بعض المصطلحات للغتنا العربية من اجل تسهيل عملية الشرح ولتبسيط المعلومة، في حالة اي خطأ املائي او اقتراح افضل للترجمة فأنا ارحب جدا بذلك يمكنك التعليق على المقال او مراسلتي لتعديل و تحسين المحتوى، ووفقنا الله وإياكم لما يحب ويرضى.
</div>]]></content><author><name>Ali Abdelaal</name></author><category term="Blog" /><category term="machine learning" /><category term="arabic" /><summary type="html"><![CDATA[في هذا المقال البسيط سوف نتعرض بشئ من التفصيل عن ماهية تعليم الآلة ما المقصود بها تحديدا و كيف تتعلم الآلة مع التطرق لبعض التفاصيل الرياضية لهذه العملية]]></summary></entry><entry><title type="html">Telegram bot tutorial using python and flask</title><link href="/blog/telegram-bot-tutorial/" rel="alternate" type="text/html" title="Telegram bot tutorial using python and flask" /><published>2020-05-12T00:00:00+00:00</published><updated>2020-05-12T00:00:00+00:00</updated><id>/blog/telegram-bot-tutorial</id><content type="html" xml:base="/blog/telegram-bot-tutorial/"><![CDATA[<script src="https://formspree.io/js/formbutton-v1.min.js" defer=""></script>

<script>
   window.formbutton=window.formbutton||function(){(formbutton.q=formbutton.q||[]).push(arguments)};
   formbutton("create", {
     title: "Hello there 👋",
     description: "Subscribe for my new content, or drop a message 🥳",
     action: "https://formspree.io/xbjzaerk",
     theme: "classic",
     fields: [{
      name: "name",
      type: "text",
      label: "Your Name",
      required: true,
      placeholder: "Say your name 🤔"
    },
    {
      name: "email",
      type: "email",
      label: "Your Email",
      placeholder: "Enter your em@il 📬",
      required: true
    },
    {
      name: "Message",
      type: "textarea",
      placeholder: "drop a message ! 🤓 if you want to 🤷‍♂️"
    },
    {
      type: "submit"
    }],
     })
</script>

<p><img src="https://www.wikitechy.com/technology/wp-content/uploads/2017/05/Telegram-Bots.png" alt="img" /></p>

<p><a href="https://www.wikitechy.com/technology/wp-content/uploads/2017/05/Telegram-Bots.png">img source</a></p>

<p>in this tutorial you will learn how to make a telegram bot and deploy it on a heroku server, the bot will be up 24-7, and you can inject your own brain and responses into it.</p>

<h2 id="before-we-start">Before we start</h2>

<p>you will need to have the following</p>

<ul>
  <li>a <a href="https://signup.heroku.com/">heroku</a> free account</li>
  <li>a <a href="https://telegram.org/">telegram</a> account of course</li>
</ul>

<h2 id="create-the-bot-on-telegram-first">Create the bot on telegram first</h2>

<p><img src="/assets/images/telegram-bot-tutorial/createbot.png" alt="bot-creating-in-telegram" /></p>

<p>before we dive into coding, let’s finish the easy stuff, we need to ask telegram to create a new bot on the platform, it’s a fairly simple process, you can do so in your telegram app(on <a href="https://telegram.org/apps">windows/linux/android/ios/web</a>) you need to go to <a href="https://telegram.me/botfather">botfather</a> which is basically a bot himself that automate the process of creating your bot.</p>

<p>you will need to ask him using the <code class="language-plaintext highlighter-rouge">/</code> prefix to start a command, once you start typing it will autocomplete itself, the command you need is <code class="language-plaintext highlighter-rouge">/newbot</code>, which will take you to the flow of creating your bot, the bot will prompt you for a name and username for the bot (the username has to be unique), then it will respone with a message like so</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Done! Congratulations on your new bot. You will find it at t.me/{bot-username}. You can now add a description, about section and profile picture for your bot, see /help for a list of commands. By the way, when you've finished creating your cool bot, ping our Bot Support if you want a better username for it. Just make sure the bot is fully operational before you do this.

Use this token to access the HTTP API:
{the-bot-token-which-we-will-use-later}
Keep your token secure and store it safely, it can be used by anyone to control your bot.

For a description of the Bot API, see this page: https://core.telegram.org/bots/api
</code></pre></div></div>

<p>congratulations you now have your bot on the platform!</p>

<h2 id="coding-the-bot-engine">Coding the bot engine</h2>

<p>before we start please note the following</p>

<ul>
  <li>i assume you use python3</li>
  <li>also my environment is ubuntu 18, it’s unlikely that this will affect your project thought.</li>
</ul>

<p>now let’s dive into some code, let’s start of by creating a <a href="https://docs.python.org/3/library/venv.html">virtualenv</a> for our project, in your terminal type</p>

<pre><code class="language-cmd">$python -m venv venv/
</code></pre>

<p>now you will have a <code class="language-plaintext highlighter-rouge">venv/</code> directory which will have all the python libraries we will be using, go ahead and activate the <code class="language-plaintext highlighter-rouge">virtualenv</code> using the following command</p>

<pre><code class="language-cmd">$source venv/bin/activate
</code></pre>

<p>now let’s have some libs installed</p>

<pre><code class="language-cmd">(venv) $pip install flask python-telegram-bot requests gunicorn
</code></pre>

<p>that’s all we need for now, let’s structure our project in a neat way before we start the real coding</p>

<pre><code class="language-cmd">.
├── app.py
├── telebot
│   ├── credentials.py
│   ├── mastermind.py
│   |   .
│   |   you can build your engine here
│   |   .
│   └── __init__.py
└── venv
</code></pre>

<p>in the <code class="language-plaintext highlighter-rouge">credentials.py</code> file we will need three variables</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bot_token</span> <span class="o">=</span> <span class="s">"place your token here"</span>
<span class="n">bot_user_name</span> <span class="o">=</span> <span class="s">"bot username"</span>
<span class="n">URL</span> <span class="o">=</span> <span class="s">"the heroku app link that we will create later"</span>
</code></pre></div></div>

<p>in <code class="language-plaintext highlighter-rouge">mastermind.py</code> you could use your super AI to generate response</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_response</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="s">"""
    you can place your mastermind AI here
    could be a very basic simple response like "معلش"
    or a complex LSTM network that generate appropriate answer

    """</span>
    <span class="k">return</span> <span class="s">"معلش !"</span>
</code></pre></div></div>

<p>now let’s go back to our <code class="language-plaintext highlighter-rouge">app.py</code> and go throw the code step by step</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># import everything
</span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">request</span>
<span class="kn">import</span> <span class="nn">telegram</span>
<span class="kn">from</span> <span class="nn">telebot.credentials</span> <span class="kn">import</span> <span class="n">bot_token</span><span class="p">,</span> <span class="n">bot_user_name</span><span class="p">,</span><span class="n">URL</span>
<span class="kn">from</span> <span class="nn">telebot.mastermind</span> <span class="kn">import</span> <span class="n">get_response</span>
</code></pre></div></div>

<p>now let’s create global objects for the bot and the token</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">global</span> <span class="n">bot</span>
<span class="k">global</span> <span class="n">TOKEN</span>
<span class="n">TOKEN</span> <span class="o">=</span> <span class="n">bot_token</span>
<span class="n">bot</span> <span class="o">=</span> <span class="n">telegram</span><span class="p">.</span><span class="n">Bot</span><span class="p">(</span><span class="n">token</span><span class="o">=</span><span class="n">TOKEN</span><span class="p">)</span>
</code></pre></div></div>

<p>at this point we have the <code class="language-plaintext highlighter-rouge">bot</code> object which is connected to your actuall bot using the token you have copied from the botfather message we saw earlier.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># start the flask app
</span><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
</code></pre></div></div>

<p>now we need to bind functions to specific routes, in other words, we need to tell flask what to do when a specific address is called, more info about flask and route can be found <a href="http://flask.pocoo.org/docs/1.0/quickstart/">here</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"""
here the route function respond to a url which is basically /{token} which is the url telegram will call to get responses for the messages sent to him.
"""</span>
<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">'/{}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">TOKEN</span><span class="p">),</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">'POST'</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">respond</span><span class="p">():</span>
    <span class="c1"># retrieve the message in JSON and then transform it to Telegram object
</span>    <span class="n">update</span> <span class="o">=</span> <span class="n">telegram</span><span class="p">.</span><span class="n">Update</span><span class="p">.</span><span class="n">de_json</span><span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="n">get_json</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span> <span class="n">bot</span><span class="p">)</span>

    <span class="c1"># get the chat_id to be able to respond to the same user
</span>    <span class="n">chat_id</span> <span class="o">=</span> <span class="n">update</span><span class="p">.</span><span class="n">message</span><span class="p">.</span><span class="n">chat</span><span class="p">.</span><span class="nb">id</span>
    <span class="c1"># get the message id to be able to reply to this specific message
</span>    <span class="n">msg_id</span> <span class="o">=</span> <span class="n">update</span><span class="p">.</span><span class="n">message</span><span class="p">.</span><span class="n">message_id</span>

    <span class="c1"># Telegram understands UTF-8, so encode text for unicode compatibility
</span>    <span class="n">text</span> <span class="o">=</span> <span class="n">update</span><span class="p">.</span><span class="n">message</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="s">'utf-8'</span><span class="p">).</span><span class="n">decode</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"got text message :"</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>

    <span class="c1"># here we call our super AI
</span>    <span class="n">response</span> <span class="o">=</span> <span class="n">get_response</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="c1"># now just send the message back
</span>    <span class="c1"># notice how we specify the chat and the msg we reply to
</span>    <span class="n">bot</span><span class="p">.</span><span class="n">sendMessage</span><span class="p">(</span><span class="n">chat_id</span><span class="o">=</span><span class="n">chat_id</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">response</span><span class="p">,</span> <span class="n">reply_to_message_id</span><span class="o">=</span><span class="n">msg_id</span><span class="p">)</span>

    <span class="k">return</span> <span class="s">'ok'</span>

</code></pre></div></div>

<p>that’s great but we need to tell telegram to call our app (the one we will create in a minute) so that our function can be invoked, for this we will use <a href="https://www.wikiwand.com/en/Webhook">webhook</a> which is in a very basic words, a way to let the bot call our server whenever a message is called, so that we dont need to make our server suffer in a while loop waiting for a message to come.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the route here can be anything, you the one who will call it
</span><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">'/setwebhook'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">'GET'</span><span class="p">,</span> <span class="s">'POST'</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">set_webhook</span><span class="p">():</span>
    <span class="c1"># we use the bot object to link the bot to our app which live
</span>    <span class="c1"># in the link provided by URL
</span>    <span class="n">s</span> <span class="o">=</span> <span class="n">bot</span><span class="p">.</span><span class="n">setWebhook</span><span class="p">(</span><span class="s">'{URL}{HOOK}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">URL</span><span class="o">=</span><span class="n">URL</span><span class="p">,</span> <span class="n">HOOK</span><span class="o">=</span><span class="n">TOKEN</span><span class="p">))</span>
    <span class="c1"># something to let us know things work
</span>    <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">"webhook setup ok"</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">"webhook setup failed"</span>
</code></pre></div></div>

<p>now everything is set, let’s just make a fancy home page so that we know the engine is up</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">'.'</span>
</code></pre></div></div>

<p>an app can’t run without a main right</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="c1"># note the threaded arg which allow
</span>    <span class="c1"># your app to have more than one thread
</span>    <span class="n">app</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">threaded</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<p>that’s the last code you will write today, now to the last step, launching our app on heroku.</p>

<h2 id="launch-our-app-on-heroku">Launch our app on heroku</h2>

<p>we need a couple of things before we make our app.</p>

<ul>
  <li>
    <p>heroku can’t know what libraries your project uses, so we have to tell him using the <code class="language-plaintext highlighter-rouge">requirements.txt</code> file (a common problem is that you misspell requirements so be careful :D), to generate the requirements file use pip</p>

    <pre><code class="language-cmd">  $pip freeze &gt; requirements.txt
</code></pre>

    <p>now you have your requirements file ready to go</p>
  </li>
  <li>
    <p>second you need the <code class="language-plaintext highlighter-rouge">Procfile</code> which tells heroku where our app starts, so create a <code class="language-plaintext highlighter-rouge">Procfile</code> file and in it type the following</p>

    <pre><code class="language-cmd">  web: gunicorn app:app
</code></pre>
  </li>
  <li>
    <p><strong>A bounce step</strong>: you can add <a href="https://github.com/github/gitignore/blob/master/Python.gitignore">.gitignore</a> file to your project so that no-use files don’t get uploaded to the repository.</p>
  </li>
  <li>
    <p>from your <a href="https://dashboard.heroku.com/apps">dashboard</a> on heroku create a new app, once you create an app it will direct you to the deploy page, open the <strong>settings</strong> tab in new window and copy the domain of the app which will be something like <code class="language-plaintext highlighter-rouge">https://appname.herokuapp.com/</code> and paste it in the URL variable inside our <code class="language-plaintext highlighter-rouge">credentials.py</code></p>
  </li>
</ul>

<p><img src="/assets/images/telegram-bot-tutorial/heroku-url.png" alt="project-url" /></p>

<p>now go back to the <strong>deploy</strong> tab and proceed with the steps:</p>
<ul>
  <li>
    <p>login to heroku</p>

    <pre><code class="language-cmd">$heroku login
</code></pre>

    <p>note that sometimes this method get stuck in <code class="language-plaintext highlighter-rouge">waiting for login</code>, if this is the case with you, you can login using</p>

    <pre><code class="language-cmd">$heroku login -i
</code></pre>
  </li>
  <li>
    <p>Initialize a git repository in our directory</p>

    <pre><code class="language-cmd">$git init
$heroku git:remote -a {heroku-project-name}
</code></pre>
  </li>
  <li>
    <p>Deploy the app</p>

    <pre><code class="language-cmd">$git add .
$git commit -m "first commit"
$git push heroku master
</code></pre>
  </li>
  <li>
    <p>at this point you will see the building progress in your terminal, if everything went okay you will see something like so</p>

    <pre><code class="language-cmd">  remote: -----&gt; Launching...
  remote:        Released v6
  remote:        https://project-name.herokuapp.com/ deployed to Heroku
  remote:
  remote: Verifying deploy... done.
</code></pre>
  </li>
  <li>
    <p>Now go to the app page (the link of the domain you copied before) and add to the end of the link <code class="language-plaintext highlighter-rouge">/setwebhook</code> so that the address will be something like <code class="language-plaintext highlighter-rouge">https://appname.herokuapp.com/setwebhook</code>, if you see <code class="language-plaintext highlighter-rouge">webhook setup ok</code> then you are ready to go!</p>
  </li>
</ul>

<h2 id="now-go-talk-to-your-bot">Now go talk to your bot</h2>

<p><img src="/assets/images/telegram-bot-tutorial/bot.gif" alt="live bot" /></p>

<h2 id="the-complete-source-code">The complete source code</h2>

<p>You can find the source code on github <a href="https://github.com/AliAbdelaal/telegram-bot-tutorial">here</a></p>

<h2 id="additional-reads">Additional reads</h2>

<ul>
  <li><a href="https://www.codementor.io/garethdwyer/building-a-telegram-bot-using-python-part-1-goi5fncay">Building a Chatbot using Telegram and Python</a></li>
  <li><a href="https://medium.com/@xabaras/setting-your-telegram-bot-webhook-the-easy-way-c7577b2d6f72">Setting your Telegram Bot WebHook the easy way</a></li>
  <li><a href="https://github.com/python-telegram-bot/python-telegram-bot">python-telegram-bot Repository</a></li>
  <li><a href="https://devcenter.heroku.com/articles/git">Deploying with Git on Heruko</a></li>
  <li><a href="https://python-telegram-bot.readthedocs.io/en/stable/index.html">Python Telegram Bot’s documentation</a></li>
</ul>]]></content><author><name>Ali Abdelaal</name></author><category term="Blog" /><category term="python" /><category term="chatbot" /><summary type="html"><![CDATA[in this tutorial you will learn how to make a telegram bot and deploy it on a heroku server, the bot will be up 24-7.]]></summary></entry></feed>